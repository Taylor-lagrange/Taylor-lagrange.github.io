<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Lab2X86 页表结构分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。线性地址的高 20 位构成页表数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低 12 位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。由于页面基地址对齐在 4K ($2^{12}$) 边界上，因此页面基地址的低 12 位肯定是 0。这意味着高 20">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab2 实验报告">
<meta property="og:url" content="http://example.com/2021/01/24/Lab2/index.html">
<meta property="og:site_name" content="lagrange&#39;s blog">
<meta property="og:description" content="Lab2X86 页表结构分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。线性地址的高 20 位构成页表数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低 12 位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。由于页面基地址对齐在 4K ($2^{12}$) 边界上，因此页面基地址的低 12 位肯定是 0。这意味着高 20">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000009450843">
<meta property="og:image" content="https://md.lagrange.plus/uploads/upload_23d235bf830085755d6a490740448aca.png">
<meta property="article:published_time" content="2021-01-24T10:47:34.000Z">
<meta property="article:modified_time" content="2021-04-23T00:27:13.503Z">
<meta property="article:author" content="lagrange">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000009450843">

<link rel="canonical" href="http://example.com/2021/01/24/Lab2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab2 实验报告 | lagrange's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lagrange's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">what's dead may never die</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab2 实验报告
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:27:13" itemprop="dateModified" datetime="2021-04-23T00:27:13Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><h2 id="X86-页表结构"><a href="#X86-页表结构" class="headerlink" title="X86 页表结构"></a>X86 页表结构</h2><p>分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。线性地址的高 20 位构成页表数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低 12 位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。由于页面基地址对齐在 4K ($2^{12}$) 边界上，因此页面基地址的低 12 位肯定是 0。这意味着高 20 位的页面基地址和 12 位偏移量连接组合在一起就能得到对应的物理地址。</p>
<p>页表中每个页表项的大小为 32 位。由于只需要其中的 20 位来存放页面的物理基地址，因此剩下的 12 位可用于存放诸如页面是否存在等的属性信息。如果线性地址索引的页表项被标注为存在的，则表示该项有效，我们可以从中取得页面的物理地址。如果页表项中信息表明（说明、指明）页不存在，那么当访问对应物理页面时就会产生一个异常。</p>
<h3 id="两级页表结构"><a href="#两级页表结构" class="headerlink" title="两级页表结构"></a>两级页表结构</h3><p>页表含有 $2^{20}$（1M）个表项，而每项占用 4 Byte。如果作为一个表来存放的话，它们最多将占用 4MB 的内存。因此为了减少内存占用量，x86 使用了两级表。由此，高 20 位线性地址到物理地址的转换也被分成两步来进行，每步使用（转换）其中的 10bit。</p>
<ol>
<li>第一级表称为页目录（page directory）。它被存放在 1 页 4K 页面中，具有 $2^{10}$（1K）个 4B 长度的表项。这些表项指向对应的二级表。线性地址的最高 10 位（位 31 ～ 22）用作一级表（页目录）中的索引值来选择 $2^{10}$ 个二级表之一。</li>
<li>第二级表称为页表（page table），它的长度也是 1 个页面，最多含有 1K 个 4B 的表项。每个 4B 表项含有相关页面的 20 位物理基地址。二级页表使用线性地址中间 10 位（位 21 ～ 12）作为表项索引值，以获取含有页面 20 位物理基地址的表项。该 20 位页面物理基地址和线性地址中的低 12 位（页内偏移）组合在一起就得到了分页转换过程的输出值，即对应的最终物理地址。</li>
</ol>
<p>CR3 寄存器指定页目录表的基地址。线性地址的高 10 位用于索引这个页目录表，以获得指向相关第二级页表的指针。线性地址中间 10 位用于索引二级页表，以获得物理地址的高 20 位。线性地址的低 12 位直接作为物理地址低 12 位，从而组成一个完整的 32 位物理地址。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断向量表和中断描述符表的区别"><a href="#中断向量表和中断描述符表的区别" class="headerlink" title="中断向量表和中断描述符表的区别"></a>中断向量表和中断描述符表的区别</h3><p>中断向量表是在实模式下使用，每个中断向量由 4 字节组成。这 4 字节指明了一个中断服务程序的段值和段内偏移值（实模式每个寄存器 16 位，基址和偏移刚好 4 字节）。当 x86 电脑上电时，BIOS 中的程序会在物理内存开始地址 0x0000:0x0000 （基址：偏移 其实就是 0 地址处）处初始化并设置中断向量表，而各中断的默认中断服务程序则在 BIOS 中给出。由于中断向量表中的向量是按中断号顺序排列，因此给定一个中断号 N，那么它对应的中断向量在内存中的位置就是 0x0000:N*4，即对应的中断服务程序入口地址保存在物理内存 0x0000:N*4 位置处。</p>
<p>在 BIOS 执行初始化操作时，它设置了两个 8259A 芯片支持的 16 个硬件中断向量和 BIOS 提供的中断号为 0x10 ～ 0x1f 的中断调用功能向量等。对于实际没有使用的向量则填入临时的哑中断服务程序的地址。以后在系统引导加载操作系统时会根据实际需要修改某些中断向量的值。例如，对于 DOS 操作系统，它会重新设置中断 0x20 ～ 0x2f 的中断向量值。而对于 Linux 系统，除了在刚开始加载内核时需要用到 BIOS 提供的显示和磁盘读操作中断功能，在内核正常运行之前则会在 setup.s 程序中重新初始化 8259A 芯片并且在 head.s 程序中重新设置一张<strong>中断描述符表</strong>。完全抛弃了 BIOS 所提供的中断服务功能。(因为 DOS 运行在实模式下，直接在原来的表上改就行了，但是 Linux 运行在保护模式下，必须使用保护模式下的<strong>中断描述符表</strong>)</p>
<p>当 Intel CPU 运行在 32 位保护模式下时，需要使用中断描述符表来管理中断或异常。其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关特权级和描述符类别等信息（中断向量表里只有地址）。</p>
<h3 id="BIOS-中断处理"><a href="#BIOS-中断处理" class="headerlink" title="BIOS 中断处理"></a>BIOS 中断处理</h3><h4 id="BIOS-为什么添加中断处理例程呢？"><a href="#BIOS-为什么添加中断处理例程呢？" class="headerlink" title="BIOS 为什么添加中断处理例程呢？"></a>BIOS 为什么添加中断处理例程呢？</h4><ol>
<li><p>给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写成中断函数，直接调用多省心。</p>
</li>
<li><p>给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了。</p>
</li>
</ol>
<h4 id="BIOS-是如何设置中断处理程序的呢？"><a href="#BIOS-是如何设置中断处理程序的呢？" class="headerlink" title="BIOS 是如何设置中断处理程序的呢？"></a>BIOS 是如何设置中断处理程序的呢？</h4><p>通过 BIOS 也要调用别人的函数例程，硬件厂商为了让自己生产的产品易用，肯定事先写好了一组调用接口，必然是越简单越好，直接给接口函数传一个参数，硬件就能返回一个输出。</p>
<p>那这些硬件自己的接口代码在哪里呢？</p>
<p>每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS 就存放在里面），不过这种内存都是只读存储器 ROM。硬件自己的功能调用例程及初始化代码就存放在这 ROM 中。根据规范，第 1 个内存单元的内容是 0x55，第 2 个存储单元是 0xAA，第 3 个存储单位是该 rom 中以 512 字节为单位的代码长度。从第 4 个存储单元起就是实际代码了，直到第 3 个存储单元所示的长度为止。</p>
<h4 id="CPU-如何访问到外设的-ROM-呢？"><a href="#CPU-如何访问到外设的-ROM-呢？" class="headerlink" title="CPU 如何访问到外设的 ROM 呢？"></a>CPU 如何访问到外设的 ROM 呢？</h4><p>访问外设有两种方式。</p>
<p>（1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。</p>
<p>（2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存。</p>
<p>从内存的物理地址 0xA0000 开始到 0xFFFFF 这部分内存中，一部分是专门用来做映射的，如果硬件存在，硬件自己的 ROM 会被映射到这片内存中的某处。</p>
<h4 id="BIOS-中断处理-1"><a href="#BIOS-中断处理-1" class="headerlink" title="BIOS 中断处理"></a>BIOS 中断处理</h4><p>BIOS 在运行期间会扫描 0xC0000 到 0xE0000 之间的内存，若在某个区域发现前两个字节是 0x55 和 0xAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第 3 个字节的值相符，说明代码无误，就从第 4 个字节进入。这时开始执行了硬件自带的例程以初始化硬件自身，最后，BIOS 填写中断向量表中相关项，使它们指向硬件自带的例程。</p>
<p>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS 的不能冲突。</p>
<p>0x20 ～ 0x27 是 DOS 中断。因为 DOS 在实模式下运行，故其可以调用 BIOS 中断。</p>
<p>DOS 中断只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程。</p>
<p>DOS 中断调用中那么多功能是如何实现的？是通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值来调用相应的子功能。</p>
<p>而 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表。</p>
<p>Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。再补充一句：如果在实模式下执行 int 指令，会自动去访问中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。</p>
<h2 id="uCore-系统内存的探测"><a href="#uCore-系统内存的探测" class="headerlink" title="uCore 系统内存的探测"></a>uCore 系统内存的探测</h2><h3 id="INT-15h-中断与-E820-参数"><a href="#INT-15h-中断与-E820-参数" class="headerlink" title="INT 15h 中断与 E820 参数"></a>INT 15h 中断与 E820 参数</h3><p>在我们分配物理内存空间前，我们必须要获取物理内存空间的信息 - 比如哪些地址空间可以使用，哪些地址空间不能使用等。在本实验中， 我们通过向 INT 15h 中断传入 e820h 参数来探测物理内存空间的信息(除了这种方法外，我们还可以使用其他的方法)。</p>
<p>下面我们来看一下 uCore 中物理内存空间的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e820map:</span><br><span class="line">  memory: 0009fc00, [00000000, 0009fbff], type &#x3D; 1.</span><br><span class="line">  memory: 00000400, [0009fc00, 0009ffff], type &#x3D; 2.</span><br><span class="line">  memory: 00010000, [000f0000, 000fffff], type &#x3D; 2.</span><br><span class="line">  memory: 07ee0000, [00100000, 07fdffff], type &#x3D; 1.</span><br><span class="line">  memory: 00020000, [07fe0000, 07ffffff], type &#x3D; 2.</span><br><span class="line">  memory: 00040000, [fffc0000, ffffffff], type &#x3D; 2.</span><br></pre></td></tr></table></figure>
<p>这里的 type 是物理内存空间的类型，1 是可以使用的物理内存空间， 2 是不能使用的物理内存空间。注意， 2 中的”不能使用”指的是这些地址不能映射到物理内存上， 但它们可以映射到 ROM 或者映射到其他设备，比如各种外设等。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>要使用这种方法来探测物理内存空间，我们必须将系统置于实模式下。因此， 我们在 bootloader 中添加了物理内存空间探测的功能。 这种方法获取的物理内存空间的信息是用内存映射地址描述符(Address Range Descriptor)来表示的，一个内存映射地址描述符占 20B，其具体描述如下：</p>
<p>00h 8 字节 base address #系统内存块基地址<br>08h 8 字节 length in bytes #系统内存大小<br>10h 4 字节 type of address range #内存类型<br>每探测到一块物理内存空间， 其对应的内存映射地址描述符就会被写入我们指定的内存空间(可以理解为是内存映射地址描述符表)。 当完成物理内存空间的探测后， 我们就可以通过这个表来了解物理内存空间的分布情况了。</p>
<blockquote>
<p>INT15h BIOS 中断的详细调用参数:</p>
<ol>
<li> eax:e820h:INT 15 的中断调用参数;</li>
<li> edx:534D4150h (即 4 个 ASCII 字符―SMAP) ,这只是一个签名</li>
<li> ebx:如果是第一次调用或内存区域扫描完毕,则为 0。 如果不是,则存放上次调用之后的计数值;</li>
<li> ecx:保存地址范围描述符的内存大小,应该大于等于 20 字节;</li>
<li> es:di:指向保存地址范围描述符结构的缓冲区,BIOS 把信息写入这个结构的起始地址。</li>
</ol>
</blockquote>
<p>下面我们来看看 INT 15h 中断是如何进行物理内存空间的探测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memlayout.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;            <span class="comment">//总共有几块内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> addr;    <span class="comment">//第i块内存块基地址</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> size;    <span class="comment">//第i块内存块大小</span></span><br><span class="line">        <span class="keyword">long</span> type;         <span class="comment">//第i块内存块种类</span></span><br><span class="line">    &#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootasm.S */</span></span><br><span class="line">probe_memory:</span><br><span class="line">    <span class="comment">/* 在 0x8000 处存放 struct e820map, 并清除 e820map 中的 nr_map */</span></span><br><span class="line">    movl $<span class="number">0</span>, <span class="number">0x8000</span></span><br><span class="line">    xorl %ebx, %ebx</span><br><span class="line">    <span class="comment">/* 0x8004 处将用于存放第一个内存映射地址描述符 */</span></span><br><span class="line">    movw $<span class="number">0x8004</span>, %di</span><br><span class="line">start_probe:</span><br><span class="line">    <span class="comment">/* 传入 0xe820 作为 INT 15h 中断的参数 */</span></span><br><span class="line">    movl $<span class="number">0xE820</span>, %eax</span><br><span class="line">    <span class="comment">/* 内存映射地址描述符的大小 */</span></span><br><span class="line">    movl $<span class="number">20</span>, %ecx</span><br><span class="line">    <span class="comment">/* SMAP=534D4150h (即 4 个 ASCII 字符―SMAP) ,这只是一个签名 */</span></span><br><span class="line">    movl $SMAP, %edx</span><br><span class="line">    <span class="comment">/* 调用 INT 15h 中断 */</span></span><br><span class="line">    <span class="keyword">int</span> $<span class="number">0x15</span></span><br><span class="line">    <span class="comment">/* 如果 eflags 的 CF 位为 0，则表示还有内存段需要探测 */</span></span><br><span class="line">    <span class="comment">/* 如果该中断执行失败，则CF标志位会置1，此时要通知UCore出错 */</span></span><br><span class="line">    jnc cont</span><br><span class="line">    <span class="comment">/* 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误 */</span></span><br><span class="line">    movw $<span class="number">12345</span>, <span class="number">0x8000</span></span><br><span class="line">    jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line">    <span class="comment">/* 设置下一个内存映射地址描述符的起始地址 */</span></span><br><span class="line">    addw $<span class="number">20</span>, %di</span><br><span class="line">    <span class="comment">/* e820map 中的 nr_map 加 1 */</span></span><br><span class="line">    incl <span class="number">0x8000</span></span><br><span class="line">    <span class="comment">/* 如果还有内存段需要探测则继续探测, 否则结束探测 */</span></span><br><span class="line">    cmpl $<span class="number">0</span>, %ebx</span><br><span class="line">    jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，要实现物理内存空间的探测，大体上只需要 3 步：</p>
<p>设置一个存放内存映射地址描述符的物理地址(这里是 0x8000)</p>
<p>将 e820 作为参数传递给 INT 15h 中断</p>
<p>通过检测 eflags 的 CF 位来判断探测是否结束。如果没有结束， 设置存放下一个内存映射地址描述符的物理地址，然后跳到步骤 2；如果结束，则程序结束</p>
<h2 id="uCore-地址空间划分"><a href="#uCore-地址空间划分" class="headerlink" title="uCore 地址空间划分"></a>uCore 地址空间划分</h2><h3 id="ld-链接脚本语言"><a href="#ld-链接脚本语言" class="headerlink" title=".ld 链接脚本语言"></a>.ld 链接脚本语言</h3><p>连接脚本的一个主要目的是描述输入文件中的节如何被映射到输出文件中,并控制输出文件的内存排布。</p>
<p>下面的脚本描述了使用该脚本链接的代码应当被载入到地址 0x10000 处, 而数据应当从 0x8000000 处开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . &#x3D; 0x10000;</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . &#x3D; 0x8000000;</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字<code>SECTIONS</code>写了这个 SECTIONS 命令, 后面跟有一串放在花括号中的符号赋值和输出节描述的内容.</p>
<p>上例中, 在<code>SECTIONS</code>命令中的第一行是对一个特殊的符号<code>.</code>赋值, 这是一个定位计数器. 如果你没有以其它的方式指定输出节的地址(其他方式在后面会描述), 那地址值就会被设为定位计数器的现有值. 定位计数器然后被加上输出节的尺寸. 在<code>SECTIONS</code>命令的开始处, 定位计数器拥有值<code>0</code>.</p>
<p>第二行定义一个输出节,<code>.text</code>. 冒号是语法需要,现在可以被忽略. 节名后面的花括号中,你列出所有应当被放入到这个输出节中的输入节的名字. ‘‘是一个通配符,匹配任何文件名. 表达式<code>(.text)</code>意思是所有的输入文件中的<code>.text</code>输入节.</p>
<p>因为当输出节<code>.text</code>定义的时候, 定位计数器的值是<code>0x10000</code>,连接器会把输出文件中的<code>.text</code>节的地址设为<code>0x10000</code>.</p>
<p>余下的内容定义了输出文件中的<code>.data</code>节和<code>.bss</code>节. 连接器会把<code>.data</code>输出节放到地址<code>0x8000000</code>处. 连接器放好<code>.data</code>输出节之后, 定位计数器的值是<code>0x8000000</code>加上<code>.data</code>输出节的长度. 得到的结果是连接器会把<code>.bss</code>输出节放到紧接<code>.data</code>节后面的位置.</p>
<p>连接器会通过在必要时增加定位计数器的值来保证每一个输出节具有它所需的对齐. 在这个例子中, 为<code>.text</code>和<code>.data</code>节指定的地址会满足对齐约束, 但是连接器可能会需要在<code>.data</code>和<code>.bss</code>节之间创建一个小的缺口。</p>
<h4 id="kernel-ld-简析-脚本部分内容被省略"><a href="#kernel-ld-简析-脚本部分内容被省略" class="headerlink" title="kernel.ld 简析(脚本部分内容被省略)"></a>kernel.ld 简析(脚本部分内容被省略)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(kern_entry) &#x2F;&#x2F; 定义函数入口为 kern_entry 函数</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义放置代码的起始虚拟地址为 0xC0100000 ，实际bootmain加载时全部与0xFFFFFF做了与运算才放入内存，所以实际上代码是被放在了0x100000处</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;0x100000后面紧接着是text代码段，其实最后也是跳转到这执行kern_entry函数</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext &#x3D; .);</span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.* .gnu.linkonce.r.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ALIGN(x)表示当前地址使用x对齐，此处的x大小刚好是4k，就是一页的大小，也就是将后面的data段对齐到 一个新的页上</span><br><span class="line">    . &#x3D; ALIGN(0x1000);</span><br><span class="line"></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; edata表示kernel的data段结束地址；end表示bss段的结束地址（即整个kernel的结束地址）</span><br><span class="line">    &#x2F;&#x2F;edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</span><br><span class="line">    PROVIDE(edata &#x3D; .);</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROVIDE(end &#x3D; .);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特殊的输出section，名为&#x2F;DISCARD&#x2F;，被该section引用的任何输入section将不会出现在输出文件内</span><br><span class="line">    &#x2F;DISCARD&#x2F; : &#123;</span><br><span class="line">        *(.eh_frame .note.GNU-stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uCore-地址空间"><a href="#uCore-地址空间" class="headerlink" title="uCore 地址空间"></a>uCore 地址空间</h3><p><img src="https://segmentfault.com/img/remote/1460000009450843" alt="uCore"></p>
<p>从 0x7c00 地址处开始看，往下在<code>bootasm.S</code>文件中 CPU 切换到保护模式的时候，<code>movw $PROT_MODE_DSEG, %ax</code>、<code>movw %ax, %ss</code>两句指令设置了栈段段描述符，<code>movl $start, %esp</code>设置了段基址为 start 段的起始地址也就是 0x7c00。x86 CPU 栈往低地址处生长且后面都没有设置栈寄存器的值，故 0x7c00 向下的地址被 bootloader 和 uCore 共用用作栈。</p>
<p>从 0x7c00 地址处往上看，<code>boot.ld</code>脚本指出了所有 bootloader 的 text、data 段放在 0x7c00 的后面。</p>
<p>0x10000 地址在<code>bootmain.c</code>中，使用<code>#define ELFHDR ((struct elfhdr *)0x10000)</code>被定义为 ELF 文件头读入的地方（后面有一些空闲地址，所以足够存放 ELF header）。</p>
<p>0x100000 地址最初被定义在<code>kernel.ld</code>中但值为<code>0xc0100000</code>，在链接的时候被放到了 ELF 头中的 program header 中。最后被<code>bootmain.c</code>读入，<code>bootmain</code> 加载时全部与 <code>0xFFFFFF</code> 做了与运算才放入内存，所以实际上代码是被放在了 <code>0x100000</code> 处，存放 uCore text 和 data 段的内容。</p>
<p>在 uCore 代码结束的地方在内存初始化函数<code>pmm_init()</code>中被用来放页表。</p>
<p>虽然低地址处有一些空闲地址（ 0x10000 前后），可以划分一些空闲页出来，但为了方便起见不进行划分，因为总共到 BIOS ROM 也只占用了 1MB 的内存，故内存浪费不可能超过 1MB。</p>
<p>为啥偏移是<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0b8e1879729a">0xC000000</a></p>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>在这个实验中，我们在 4 个不同的阶段进行了 4 次地址映射， 下面我就分别介绍这 4 次地址映射。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>这一阶段是从 bootasm.S 的 start 到 entry.S 的 kern_entry 前。这个阶段只是简单的设置了段表，和 lab1 一样(这时的 GDT 中每个段的起始地址都是 0x00000000 并且此时 kernel 还没有载入)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="meta"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           <span class="meta"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 <span class="meta"># data seg for bootloader and kernel</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word <span class="number">0x17</span>                                      <span class="meta"># sizeof(gdt) - 1</span></span><br><span class="line">    .<span class="keyword">long</span> gdt                                       <span class="meta"># address gdt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>virt addr = linear addr = phy addr</p>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>这个阶段就是从 entry.S 的 kern_entry 到 pmm.c 的 page_init()。 这个阶段开启了页机制并简单的设置了一个页表。将虚拟地址 0xC0000000 ~ 0xC0000000 +4M 映射到物理地址 0 ~ 4M。暂时解决了 OS 代码中地址为 0xC0000000+x 但实际物理地址在 x 的问题</p>
<p>下面介绍页表开启过程。</p>
<blockquote>
<p>CR0 中包含了 6 个预定义标志，0 位是保护允许位 PE(Protedted Enable)，用于启动保护模式，如果 PE 位置 1，则保护模式启动，如果 PE=0，则在实模式下运行。1 位是监控协处理位 MP(Moniter coprocessor)，它与第 3 位一起决定：当 TS=1 时操作码 WAIT 是否产生一个“协处理器不能使用”的出错信号。第 3 位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置 1。随着 TS=1，就不能使用协处理器。CR0 的第 2 位是模拟协处理器位 EM (Emulate coprocessor)，如果 EM=1，则不能使用协处理器，如果 EM=0，则允许使用协处理器。第 4 位是微处理器的扩展类型位 ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果 ET=0，则标识系统使用的是 287 协处理器，如果 ET=1，则表示系统使用的是 387 浮点协处理器。<strong>CR0 的第 31 位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。</strong></p>
</blockquote>
<blockquote>
<p>CR3 是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以 4K 字节为单位的存储器边界上，因此，它的地址的低 12 位总为 0，不起作用，即使写上内容，也不会被理会。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br></pre></td></tr></table></figure>
<p>连接文件将 kernel 链接到了 0xC0100000，这个地址是 kernel 的虚拟地址。CR3 寄存器使用的地址是实际物理地址，所以需要使用宏将虚地址转变为实际物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE    0xC0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REALLOC(x) (x - KERNBASE)</span></span><br><span class="line"></span><br><span class="line">kern_entry:</span><br><span class="line">    <span class="meta"># load pa of boot pgdir</span></span><br><span class="line">    movl $REALLOC(__boot_pgdir), %eax</span><br><span class="line">    movl %eax, %cr3 <span class="comment">//将页目录基址载入CR3寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># enable paging</span></span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">    andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line">    movl %eax, %cr0 <span class="comment">//重新设置CR0寄存器，开启分页</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># update eip</span></span><br><span class="line">    <span class="meta"># now, eip = 0x1.....</span></span><br><span class="line">    leal next, %eax</span><br><span class="line">    <span class="meta"># set eip = KERNBASE + 0x1.....</span></span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br><span class="line">    <span class="comment">//设置完eip后立马umap</span></span><br><span class="line">    # unmap va 0 ~ 4M, it&#x27;s temporary mapping</span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    movl %eax, __boot_pgdir</span><br></pre></td></tr></table></figure>
<p>之所以设置 0 ~ 4M - 0 ~ 4M 的映射，后面又立马取消是因为。在开启分页的时候，eip 指向当前执行命令的地址（小于 4M 的某个地址），如果没有设置 0 ~ 4M 的映射，让 eip 继续往下走，CPU 不知道 0 ~ 4M 对应哪一个物理地址肯定崩。所以先设置好地址，保证开启后程序不崩溃，之后通过跳转到 next ，eip 的值被设置为 next 的地址。因为 next 被定义在 kernel 里这是一个 3G 以上的内存地址，所以 eip 就被设置成了 3G 以上的地址，可以正确的往下执行。在跳转后原来的 0 ~ 4M 就被立刻置为 0 删除之。</p>
<p>下面来看载入的页目录表和页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.align PGSIZE  <span class="comment">//页目录必须按页大小对齐，整个页目录占一个页</span></span><br><span class="line">__boot_pgdir:</span><br><span class="line">.globl __boot_pgdir</span><br><span class="line">    <span class="comment">// 将第一个页目录项对应的地址映射到0 ~ 4M。map va 0 ~ 4M to pa 0 ~ 4M (temporary)</span></span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    <span class="comment">// 填充剩余表项直到对应虚地址0xC0000000的地方</span></span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; <span class="number">10</span> &lt;&lt; <span class="number">2</span>) - (. - __boot_pgdir) <span class="meta"># pad to PDE of KERNBASE</span></span><br><span class="line">    <span class="comment">// 将0xC0000000~0xC0000000+4M的虚地址映射到0 ~ 4M。 map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M</span></span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    <span class="comment">// .space申请一段空间将整个页目录填满（否则有一些OS代码可能会被安排到这个页目录的剩余空间）</span></span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir)</span><br><span class="line"></span><br><span class="line">.<span class="built_in">set</span> i, <span class="number">0</span>  <span class="comment">//通过循环的方式设置了对应虚地址 - 0~4M 的映射 （这个页表放哪个页表项，哪个页表项就指向0~4M）</span></span><br><span class="line">__boot_pt1:</span><br><span class="line">.rept <span class="number">1024</span></span><br><span class="line">    .<span class="keyword">long</span> i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line">    .<span class="built_in">set</span> i, i + <span class="number">1</span></span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>
<p>这个阶段结束后，OS 的代码段（0xC0000000 ~ 0xC0000000+4M），三个地址的关系是：</p>
<p>virt addr = linear addr = phy addr + 0xC0000000</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>这个阶段就是 pmm.c 的 <code>boot_map_segment()</code> 函数, 将 0x30000000<del>0x38000000 这段线性地址映射到了物理地址 0x00000000</del>0x08000000。</p>
<p>在解释这个函数前先对 OS 管理内存的数据结构<code>Page</code>进行介绍。</p>
<p>在 OS 中每一个页都有一个 Page 的数据结构进行管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame&#x27;s reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记录引用次数、页面状态，并有用于管理空闲内存的链接指针。在执行<code>boot_map_segment</code>前，函数<code>page_init</code>对操作系统的页表进行了初始化（一共有两个页表，一个是操作系统用来管理内存所建立的 c 语言数据结构，另外一个是给 CPU 用来做地址转换的内存数据）。pmm.c 中定义了 pages 变量用来存储<code>Page</code>数据组的首地址。该数组放在 OS 代码结束的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMEMSIZE 0x38000000 <span class="comment">//the maximum amount of physical memory</span></span></span><br><span class="line"></span><br><span class="line">page_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (struct e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="keyword">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历探测出的内存块，找出可用的最大物理地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM)</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE)</span><br><span class="line">                maxpa = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大物理地址不能超出KMEMSIZE的限定</span></span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该值由ld链接脚本提供，这个地址是os代码结束的地址</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要分页的数量</span></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将os代码结束地址向上取整拿来放页表</span></span><br><span class="line">    pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)end, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简化起见，从物理0地址到页表结束的地址pages+ sizeof(struct Page) * npage)</span></span><br><span class="line">    <span class="comment">//设定为已占用物理内存空间（起始0~640KB的空间是空闲的）</span></span><br><span class="line">    <span class="comment">//地址pages+ sizeof(struct Page) * npage)以上的空间为空闲物理内存空间</span></span><br><span class="line">    <span class="comment">//这为了方便把所有的页都设置为已占用，后面再改回来</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个可用的空闲页地址</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对上面所有探测到的内存卡</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="comment">//如果该内存块是可用内存</span></span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem)</span><br><span class="line">                begin = freemem;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE)</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end)</span><br><span class="line">                    <span class="comment">//（起始地址对应的页表，总共有几页）进行页表的初始化</span></span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数<code>page_init()</code>执行完成后，我们完成了操作系统页表的建立，注意这个页表只是操作系统用来管内存的，其具体的映射关系是：</p>
<p><strong>pages[物理地址&gt;&gt;12] = 该物理地址所在页面的使用情况</strong></p>
<p>下面的<code>boot_map_segment</code>函数填写线性地址到物理地址的映射关系，<code>get_pte</code> 返回该线性地址所在的页面（没有对应的页面向 OS 申请一个）。从 0x30000000 开始，一页一页的填地址映射关系（for 以页为单位迭代）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map all physical memory to linear memory with base linear addr KERNBASE</span></span><br><span class="line"><span class="comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span></span><br><span class="line">boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">//boot_map_segment - setup&amp;enable the paging mechanism</span></span><br><span class="line"><span class="comment">// parameters</span></span><br><span class="line"><span class="comment">//  la:   linear address of this memory need to map (after x86 segment map)</span></span><br><span class="line"><span class="comment">//  size: memory size</span></span><br><span class="line"><span class="comment">//  pa:   physical address of this memory</span></span><br><span class="line"><span class="comment">//  perm: permission of this memory</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_segment(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">size_t</span> size, <span class="keyword">uintptr_t</span> pa, <span class="keyword">uint32_t</span> perm) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;</span><br><span class="line">    la = ROUNDDOWN(la, PGSIZE);</span><br><span class="line">    pa = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --, la += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(pgdir, la, <span class="number">1</span>);</span><br><span class="line">        *ptep = pa | PTE_P | perm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这个函数后 0x30000000<del>0x38000000 这段线性地址被映射到了物理地址 0x00000000</del>0x08000000</p>
<p>下面简单总结一下各个数据结构在内存中的位置：</p>
<ol>
<li>页目录表：占一页大小，在<code>entry.S</code>里被定义在了内核代码的数据段。</li>
<li>OS 管理页面结构数组 pages : 根据探测到的内存在 OS 代码结尾处进行分配。</li>
<li>页表：空闲内存中（pages 结束向上的空闲内存）</li>
</ol>
<p>再介绍下<code>get_pte</code>函数作为练习 2 的 lab</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)];</span><br><span class="line">    <span class="comment">// 如果该条目不可用(not present)</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span></span><br><span class="line">        <span class="comment">// alloc_page 返回的是pages数组中的page地址</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 设置该物理页面的引用次数为1</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取当前page所管理的物理地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line">        <span class="comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// 将新分配的页面设置为当前缺失的页目录条目中</span></span><br><span class="line">        <span class="comment">// 之后该页面就是其中的一个二级页面</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回在pgdir中对应于la的二级页表项</span></span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>第四阶段为 pmm.c 的<code>gdt_init()</code>函数设置了新的段表，相比旧段表只有内核代码段和内核数据段增加了用户的代码和内核段。建立起了整个操作系统的内存模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="meta"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           <span class="meta"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 <span class="meta"># data seg for bootloader and kernel</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Global Descriptor Table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The kernel and user segments are identical (except for the DPL). To load</span></span><br><span class="line"><span class="comment"> * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the</span></span><br><span class="line"><span class="comment"> * segments for the user and the kernel. Defined as follows:</span></span><br><span class="line"><span class="comment"> *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line"><span class="comment"> *   - 0x8 :  kernel code segment</span></span><br><span class="line"><span class="comment"> *   - 0x10:  kernel data segment</span></span><br><span class="line"><span class="comment"> *   - 0x18:  user code segment</span></span><br><span class="line"><span class="comment"> *   - 0x20:  user data segment</span></span><br><span class="line"><span class="comment"> *   - 0x28:  defined for tss, initialized in gdt_init</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了上面的四个阶段，下面根据这张图对内存地址的映射关系进行描述，因为在实验中我们设置了最大只能管理 896M 的内存（KMEMSIZE），所以整个物理地址空间只是从 0~896M。</p>
<p>首先从虚拟地址到线性地址的映射，该阶段由段表完成，阶段 1、4 设置了段表，但全是恒等映射，虚拟地址永远等于线性地址不变。两个阶段的不同之处只是在于阶段 4 增加了用户的代码数据段。</p>
<p>然后就是从线性地址到实际物理地址的映射，阶段 2 将线性地址 3G ~ 3G +4M 映射到物理地址 0 ~ 4M(在阶段 3 被保存了下来)。阶段 3 将线性地址 3G ~ 3G + 896M 映射到物理地址 0 ~ 896M。</p>
<p>一直到页表结束，空闲内存开始的地方的物理地址应该是 &lt; 4M 的，所以在这个实验中，所有的虚地址都是从 3G 以上开始，被映射到了 0 ~ 896M</p>
<h2 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h2><p>页表自映射的思想是，把所有的页表（4KB）放到连续的 4MB 虚拟地址 空间中，并且要求这段空间 4MB 对齐，这样，会有一张页表的内容与页目录的内容完全相同，从而节省了页目录的空间。代价则是需要从虚拟地址空间中分配出连续的 4MB 对齐的 4MB 的空间。</p>
<p><img src="https://md.lagrange.plus/uploads/upload_23d235bf830085755d6a490740448aca.png" alt="自映射"></p>
<p>自映射时的页表结构</p>
<p>上图中，页表和页目录都位于虚拟地址空间的连续内存中，换句话说，这 4MB 的页表可以对应到虚拟地址空间的一个 Table Frame 中。</p>
<p>我们采用上图中的术语描述所谓的自映射关系。</p>
<ol>
<li>页表位于 Table Frame x</li>
<li>Table Frame x 中的每个 4KB 大小的 Page Frame 0-1023 分别存储了页表的 Table 0-1023</li>
<li>页目录的 Entry 0-1023 也需要分别指向页表的 Table 0-1023。</li>
<li>Table x 指向了 Table Frame x。（注意这里的 x，是相同的 x）</li>
<li>Table x 中的页表项（Page Table Entry, PTE）0-1023，分别指向 Table Frame x 的 1024 个 Page Frame（4KB）,也就是 Table 0-1023（根据第【2】条）。</li>
<li>Table x 等价于页目录。页目录中的 Entry x 指向 Table x。这就被称为自映射，节省了页目录的 4KB 空间。</li>
</ol>
<p>就是说 Table x 和页目录里面的内容相同，既然相同，Table x 也不用进行分配，直接在 Entry x 填 page dictionary 就行。</p>
<p>所以可以观察到,OS 先将那个 Entry x 填上自己的地址，再进行页表的初始化操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursively insert boot_pgdir in itself</span></span><br><span class="line"><span class="comment">// to form a virtual page table at virtual address VPT</span></span><br><span class="line">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map all physical memory to linear memory with base linear addr KERNBASE</span></span><br><span class="line"><span class="comment">// linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE</span></span><br><span class="line">boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/24/Lab5/" rel="prev" title="Lab5 实验报告">
      <i class="fa fa-chevron-left"></i> Lab5 实验报告
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/24/Lab1/" rel="next" title="Lab1 实验报告">
      Lab1 实验报告 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab2"><span class="nav-number">1.</span> <span class="nav-text">Lab2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#X86-%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">X86 页表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">两级页表结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">1.2.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">中断向量表和中断描述符表的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIOS-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">BIOS 中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIOS-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BE%8B%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">BIOS 为什么添加中断处理例程呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIOS-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">BIOS 是如何设置中断处理程序的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%88%B0%E5%A4%96%E8%AE%BE%E7%9A%84-ROM-%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">CPU 如何访问到外设的 ROM 呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIOS-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86-1"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">BIOS 中断处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore-%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%A2%E6%B5%8B"><span class="nav-number">1.3.</span> <span class="nav-text">uCore 系统内存的探测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INT-15h-%E4%B8%AD%E6%96%AD%E4%B8%8E-E820-%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">INT 15h 中断与 E820 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">实现过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="nav-number">1.4.</span> <span class="nav-text">uCore 地址空间划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ld-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">.ld 链接脚本语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-ld-%E7%AE%80%E6%9E%90-%E8%84%9A%E6%9C%AC%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E8%A2%AB%E7%9C%81%E7%95%A5"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">kernel.ld 简析(脚本部分内容被省略)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uCore-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.2.</span> <span class="nav-text">uCore 地址空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">1.5.</span> <span class="nav-text">地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">第一阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.2.</span> <span class="nav-text">第二阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.3.</span> <span class="nav-text">第三阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.4.</span> <span class="nav-text">第四阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">自映射机制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lagrange</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lagrange</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
