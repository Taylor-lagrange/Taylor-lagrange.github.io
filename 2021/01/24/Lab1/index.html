<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Lab1 实验报告&#x2F;labcodes_answer&#x2F;lab1_result&#x2F; 目录下的代码，在用较新版本（好像是 GCC 5.x 开始）就会出现生成的 bootloader 二进制文件过大无法塞入第一个扇区的问题，这种情况只需要将 &#x2F;labcodes_answer&#x2F;lab1_result&#x2F;boot&#x2F;bootmain.c中的全局变量改为用宏定义即可编译通过。 123unsigned int SECT">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab1 实验报告">
<meta property="og:url" content="http://example.com/2021/01/24/Lab1/index.html">
<meta property="og:site_name" content="lagrange&#39;s blog">
<meta property="og:description" content="Lab1 实验报告&#x2F;labcodes_answer&#x2F;lab1_result&#x2F; 目录下的代码，在用较新版本（好像是 GCC 5.x 开始）就会出现生成的 bootloader 二进制文件过大无法塞入第一个扇区的问题，这种情况只需要将 &#x2F;labcodes_answer&#x2F;lab1_result&#x2F;boot&#x2F;bootmain.c中的全局变量改为用宏定义即可编译通过。 123unsigned int SECT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000009386096?w=640&h=300">
<meta property="og:image" content="https://md.lagrange.plus/uploads/upload_9f1f9e574d09eab7da5d82fd3636b561.png">
<meta property="og:image" content="https://md.lagrange.plus/uploads/upload_11fd42ee568230926dd27f08d50957e6.png">
<meta property="og:image" content="https://md.lagrange.plus/uploads/upload_85d13f38c3c4636e196ba2a53b33436f.png">
<meta property="article:published_time" content="2021-01-24T10:47:34.000Z">
<meta property="article:modified_time" content="2021-04-23T00:26:39.389Z">
<meta property="article:author" content="lagrange">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000009386096?w=640&h=300">

<link rel="canonical" href="http://example.com/2021/01/24/Lab1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab1 实验报告 | lagrange's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lagrange's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">what's dead may never die</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/24/Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lagrange">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lagrange's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab1 实验报告
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 10:47:34" itemprop="dateCreated datePublished" datetime="2021-01-24T10:47:34Z">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 00:26:39" itemprop="dateModified" datetime="2021-04-23T00:26:39Z">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab1-实验报告"><a href="#Lab1-实验报告" class="headerlink" title="Lab1 实验报告"></a>Lab1 实验报告</h1><p><code>/labcodes_answer/lab1_result/</code> 目录下的代码，在用较新版本（好像是 GCC 5.x 开始）就会出现生成的 <code>bootloader</code> 二进制文件过大无法塞入第一个扇区的问题，这种情况只需要将 <code>/labcodes_answer/lab1_result/boot/bootmain.c</code>中的全局变量改为用宏定义即可编译通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SECTSIZE  = <span class="number">512</span> ;</span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE 512</span></span><br></pre></td></tr></table></figure>
<h2 id="make-生成执行文件的过程"><a href="#make-生成执行文件的过程" class="headerlink" title="make 生成执行文件的过程"></a>make 生成执行文件的过程</h2><h3 id="操作系统镜像文件-ucore-img-是如何一步一步生成的"><a href="#操作系统镜像文件-ucore-img-是如何一步一步生成的" class="headerlink" title="操作系统镜像文件 ucore.img 是如何一步一步生成的"></a>操作系统镜像文件 ucore.img 是如何一步一步生成的</h3><p>Makefile 的终极目标在第 207 行被显式指定为 205 行的 <code>TARGETS</code> ，而 <code>TARGETS</code> 的依赖为 <code>$(TARGETS)</code> ，这个变量在 Makefile 只是空的，但是会在 <code>tools/function.mk</code> 中的 <code>do_create_target</code> 宏中被修改， <code>do_create_target</code> 被函数 <code>create_target</code> 直接调用。因此在 Makefile 中只要调用了 <code>create_target</code> 就会为 <code>$(TARGETS)</code> 增添新的一项。</p>
<p>经过一系列的 <code>create_target</code> ， <code>$(TARGETS)</code> 最终值为 <code>bin/kernel bin/bootblock bin/sign bin/ucore.img</code></p>
<p>首先看<code>bin/kernel</code>的文件依赖</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span> tools/kernel.ld</span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">    <span class="comment">#最终的内核文件应该去除符号表等信息，并输出符号表信息，汇编文件信息，和输出信息</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br></pre></td></tr></table></figure>
<p>显示这段代码执行的输出可以看到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br></pre></td></tr></table></figure>
<p>ld 命令参数：</p>
<ul>
<li>m &lt;emulation&gt; 模拟为 i386 上的连接器</li>
<li>nostdlib 不要在标准系统目录中寻找头文件.只搜索`-I’选项指定的目录(以及当前目录,如果合适).</li>
<li>T &lt;scriptfile&gt; 让连接器使用指定的脚本</li>
</ul>
<p>所谓的<code>KOBJS</code>就是那串跟在<code>-o</code> 后面的，在<code>\lib</code>,<code>\kern</code>文件夹中所有.c .S 文件生成.o 二进制文件。通过<code>ld</code>的链接指令完成了 <code>bin/kernel</code> 文件的生成。 至于下面的的使用<code>@</code>隐藏输出的<code>OBJDUMP</code>,应该是删符号表等信息。</p>
<p>至于在<code>ld</code>命令前的.o 文件生成指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br></pre></td></tr></table></figure>
<p>gcc 参数：</p>
<ul>
<li>-fno-builtin 除非用 __builtin__ 前缀，否则不进行 builtin 函数的优化</li>
<li>-Wall 选项意思是编译后显示所有警告。</li>
<li>-ggdb 生成可供 gdb 使用的调试信息。这样才能用 qemu+gdb 来调试 bootloader or ucore。</li>
<li>-m32 生成适用于 32 位环境的代码。我们用的模拟硬件是 32bit 的 80386，所以 ucore 也要是 32 位的软件。</li>
<li>-gstabs 生成 stabs 格式的调试信息。这样要 ucore 的 monitor 可以显示出便于开发者阅读的函数调用栈信息</li>
<li>-nostdinc 不使用标准库。标准库是给应用程序用的，我们是编译 ucore 内核，OS 内核是提供服务的，所以所有的服务要自给自足。</li>
<li>-fno-stack-protector 不生成用于检测缓冲区溢出的代码。这是 for 应用程序的，我们是编译内核，ucore 内核好像还用不到此功能。</li>
<li>-I&lt;dir&gt; 添加搜索头文件的路径</li>
<li>-c Compile and assemble, but do not link.</li>
</ul>
<p>是在第 126 行左右执行的<code>$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))</code></p>
<p>该命令对所有 kern 和 lib 下的 .c .S 文件执行了编译操作生成.o 文件。</p>
<p>紧接上面，之后的输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br></pre></td></tr></table></figure>
<p>gcc 参数：</p>
<ul>
<li>-Os 为减小代码大小而进行优化。根据硬件 spec，主引导扇区只有 512 字节，我们写的简单 bootloader 的最终大小不能大于 510 字节。</li>
</ul>
<p>来自于下面两条指令</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br></pre></td></tr></table></figure>
<p>第一条语句找出<code>\boot</code>文件夹下的所有以.S .c 结尾的文件<code>bootasm.S</code>,<code>bootmain.c</code>,第二句话对上面找出的两个文件执行编译。 其中<code>bootasm.S</code>依赖于<code>\boot</code>文件夹下的的<code>asm.h</code>头文件。引入该头文件的方法是在 gcc 编译指令中加上<code>-Iboot/</code>这个参数。<code>-I&lt;dir&gt; 添加搜索头文件的路径</code>，根据这个参数可以找到位于<code>\boot</code>文件夹下的的<code>asm.h</code>头文件</p>
<p>下面的输出是对 sign 工具的编译。虽然在 makefile 文件下紧接着的是对 bootblock 的编译，但是因为 bootblock 依赖于 sign 工具，故首先执行 sign 工具的编译操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create &#x27;sign&#x27; tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br></pre></td></tr></table></figure>
<p>该生成由以上两句语句生成并输出</p>
<p>解决了 sign 工具的依赖后开始生成 bootblock,输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">&#x27;obj/bootblock.out&#x27; size: 488 bytes</span><br><span class="line">build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br></pre></td></tr></table></figure>
<p>新出现的 ld 命令参数：</p>
<ul>
<li>e &lt;entry&gt; 指定入口</li>
<li>N 设置代码段和数据段均可读写</li>
<li>Ttext 制定代码段开始位置,0x7C00 就是 bios 执行完后程序开始执行的位置</li>
</ul>
<p>对应 makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br></pre></td></tr></table></figure>
<p>objcopy 拷贝二进制代码 bootblock.o 到 bootblock.out:</p>
<ul>
<li>-S 移除所有符号和重定位信息</li>
<li>-O <bfdname> 指定输出格式</li>
</ul>
<p>调用 sign 进行签名（这里只显示了 sign 程序执行时的输出，并没有显示调用 sign 程序的指令）：</p>
<p><code>sign bootblock.out bootblock</code>(大概是这个意思)</p>
<p>sign 函数执行的逻辑就是在文件小于 510 个字节的情况下将最后两个字节置为 0x55AA 标志该启动扇区是合法的。</p>
<p>执行以上代码后完成 bootblock 的构造，最后执行 ucore.img 的构造</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line"></span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0213187 s, 240 MB/s</span><br><span class="line"></span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line"></span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.997e-05 s, 5.7 MB/s</span><br><span class="line"></span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line"></span><br><span class="line">146+1 records in</span><br><span class="line">146+1 records out</span><br><span class="line">74923 bytes (75 kB) copied, 0.000318176 s, 235 MB/s</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UCOREIMG	:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<ol>
<li>生成一个有 10000 个块的文件，每个块默认 512 字节，用 0 填充<br>dd if=/dev/zero of=bin/ucore.img count=10000</li>
<li>把 bootblock 中的内容写到第一个块<br>dd if=bin/bootblock of=bin/ucore.img conv=notrunc</li>
<li>从第二个块开始写 kernel 中的内容<br>dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</li>
</ol>
<blockquote>
<p>/dev/zero ： 在类 UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD 就是通过 mmap 把/dev/zero 映射到虚地址空间实现共享内存的。可以使用 mmap 将/dev/zero 映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。</p>
</blockquote>
<blockquote>
<p>if=文件名：输入文件名，默认为标准输入。即指定源文件。<br>of=文件名：输出文件名，默认为标准输出。即指定目的文件。<br>count=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。 notrunc：不截短输出文件</p>
</blockquote>
<h3 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取输入文件的状态</span></span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) <span class="comment">//不存在报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) <span class="comment">//文件大于510个字节报错，虽然启动扇区能够装512个字节，但最后两个字节必须是0x55AA来标志该扇区为合法的启动扇区，所以最多装510个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);          <span class="comment">//argv[0]是程序全名，argv[1]是输入文件，即以读二进制文件的方法打开输入文件</span></span><br><span class="line">    <span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp); <span class="comment">//从ifp读st.st_size个对象，每个对象读一次到buf中</span></span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>; <span class="comment">//把最后两个字节写成0x55AA</span></span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); <span class="comment">//写回到输出</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合规范的硬盘主引导扇区 size=512bytes，并且第 511 个 byte 值为 0x55，第 512 个 byte 的值为 0xAA</p>
<h2 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h2><ol>
<li>x86 PC 刚开机时 CPU 处于实模式</li>
<li>开机时，CS=0xFFFF; IP=0x0000</li>
<li>寻址 0xFFFF0(ROM BIOS 映射区)</li>
<li>检查 RAM，键盘，显示器，软硬磁盘</li>
<li>将磁盘 0 磁道 0 扇区读入 0x7c00 处</li>
<li>设置 cs=0x07c0，ip=0x0000</li>
</ol>
<h2 id="分析-bootloader-进入保护模式的过程"><a href="#分析-bootloader-进入保护模式的过程" class="headerlink" title="分析 bootloader 进入保护模式的过程"></a>分析 bootloader 进入保护模式的过程</h2><h3 id="为何开启-A20，以及如何开启-A20"><a href="#为何开启-A20，以及如何开启-A20" class="headerlink" title="为何开启 A20，以及如何开启 A20"></a>为何开启 A20，以及如何开启 A20</h3><p>在 i8086 时代，CPU 的数据总线是 16bit，地址总线是 20bit，寄存器是 16bit，因此 CPU 只能访问 1MB 以内的空间。因为数据总线和寄存器只有 16bit，如果需要获取 20bit 的数据, 需要 segment(每个 segment 大小恒定为 64K)左移 4 位再加上 offset 组成一个 20bit 的地址。理论上，20bit 的地址可以访问 1MB 的内存空间(0x00000 - (2^20 - 1 = 0xFFFFF))。但在实模式下, 这 20bit 的地址理论上能访问从 0x00000 - (0xFFFF0 + 0xFFFF = 0x10FFEF)的内存空间。也就是说，理论上我们可以访问超过 1MB 的内存空间，但越过 0xFFFFF 后，地址又会回到 0x00000。上面这个特征在 i8086 中是没有任何问题的(因为它最多只能访问 1MB 的内存空间)，但到了 i80286/i80386 后，CPU 有了更宽的地址总线，数据总线和寄存器后，这就会出现一个问题： 在实模式下, 我们可以访问超过 1MB 的空间，但我们只希望访问 1MB 以内的内存空间。为了解决这个问题， CPU 中添加了一个可控制 A20 地址线的模块，通过这个模块，我们在实模式下将第 20bit 的地址线限制为 0，这样 CPU 就不能访问超过 1MB 的空间了。进入保护模式后，我们再通过这个模块解除对 A20 地址线的限制，这样我们就能访问超过 1MB 的内存空间了。</p>
<p>现在使用的 CPU 都是通过键盘控制器 8042 (端口 0x64 和 0x60 连着键盘控制器) 来控制 A20 地址线。默认情况下，A20 地址线是关闭的(限制只能访问 1M 内存)，因此在进入保护模式(需要访问超过 1MB 的内存空间)前，我们需要开启 A20 地址线(第 20bit 的地址线可为 0 或者 1)。开启代码在 bootasm.S 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br></pre></td></tr></table></figure>
<p>cpu 可以直接读写以下三个地方的数据，读写三个地方的指令都是不同的，他们的空间也是分开的。</p>
<ol>
<li>端口</li>
<li>内存</li>
<li>寄存器</li>
</ol>
<p>对外设的控制都是通过读写对应外设的端口来完成的。对端口的读写汇编指令只有 in 和 out。</p>
<p>由于当时的 8042 键盘控制器上恰好有空闲的端口引脚（输出端口 P2，引脚 P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为 A20。如果它为零，则比特 20 及以上地址都被清除。从而实现了兼容性。</p>
<p>当 A20 地址线控制禁止时，程序就像运行在 8086 上，1MB 以上的地址是不可访问的，只能访问奇数 MB 的不连续的地址。为了使能所有地址位的寻址能力，必须向键盘控制器 8082 发送一个命令，键盘控制器 8042 会将 A20 线置于高电位，使全部 32 条地址线可用，实现访问 4GB 内存。</p>
<p>控制 A20 gate 的方法有 3 种：</p>
<ol>
<li>804x 键盘控制器法</li>
<li>Fast A20 法</li>
<li>BIOS 中断法</li>
</ol>
<p>ucore 实验中用了第一种 804x 键盘控制器法，这也是最古老且效率最慢的一种。由于在机器启动时，默认条件下，A20 地址线是禁止的，所以操作系统必须使用适当的方法来开启它。</p>
<p>等待 8042 Input buffer 为空；<br>发送 Write 8042 Output Port （P2）命令到 8042 Input buffer；<br>等待 8042 Input buffer 为空；<br>将 8042 Output Port（P2）得到字节的第 2 位置 1，然后写入 8042 Input buffer</p>
<h3 id="如何初始化-GDT-表"><a href="#如何初始化-GDT-表" class="headerlink" title="如何初始化 GDT 表"></a>如何初始化 GDT 表</h3><p>在保护模式下，x86 CPU 通过 GDT 表访问内存，我们根据 CPU 给的逻辑地址分离出段选择子。利用这个段选择子选择一个段描述符。将段描述符里的 Base Address 和段选择子的偏移量相加而得到线性地址。这个地址就是我们需要的地址。</p>
<p><img src="https://segmentfault.com/img/remote/1460000009386096?w=640&h=300" alt="GDT"></p>
<p>在实模式下，通过 segment + offset 的方式一个程序可以访问内存中的任意一个地址，但是开启了保护模式之后，段选择子和段描述符中都有了特权级的概念，程序不能随意访问高特权级的段内容。段表有固定的格式被放到内存中，CPU 使用全局描述符表寄存器 GDTR 保存段表起始地址。GDTR 长 48 位，其中高 32 位为基地址，低 16 位为段界限。这里只需要载入已经静态存储在引导区的 GDT 表和其描述符到 GDTR 寄存器。理论上 GDT 可以存在内存中任何位置，但这里我们是在实模式下初始化 GDT 的，因此 GDT 应该是存在最低的这 1MB 内存空间中。CPU 通过 lgdt 指令读入 GDT 的地址，之后我们就可以使用 GDT 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#注释：#include &lt;asm.h&gt;</span><br><span class="line">asm.h头文件中包含了一些宏定义，用于定义gdt，gdt是保护模式使用的全局段描述符表，其中存储着段描述符。</span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line">此段注释说明了要完成的目的：启动保护模式，转入C函数。</span><br><span class="line">这里正好说了一下bootasm.S文件的作用。计算机加电后，由BIOS将bootasm.S生成的可执行代码从硬盘的第一个扇区复制到内存中的物理地址0x7c00处,并开始执行。</span><br><span class="line">此时系统处于实模式。可用内存不多于1M。</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">这两个段选择子的作用其实是提供了gdt中代码段和数据段的索引</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line">这个变量是开启A20地址线的标志，为1是开启保护模式</span><br><span class="line"></span><br><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">这两行代码相当于定义了C语言中的main函数，start就相当于main，BIOS调用程序时，从这里开始执行</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">因为以下代码是在实模式下执行，所以要告诉编译器使用16位模式编译。</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line">关中断，设置字符串操作是递增方向。cld的作用是将direct flag标志位清零，这意味着自动增加源索引和目标索引的指令(如MOVS)将同时增加它们。</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">ax寄存器就是eax寄存器的低十六位，使用xorw清零ax，效果相当于movw $0, %ax。 但是好像xorw性能好一些，google了一下没有得到好答案</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line">将段选择子清零</span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">准备工作就绪，下面开始动真格的了，激活A20地址位。先翻译注释：由于需要兼容早期pc，物理地址的第20位绑定为0，所以高于1MB的地址又回到了0x00000.</span><br><span class="line">好了，激活A20后，就可以访问所有4G内存了，就可以使用保护模式了。</span><br><span class="line"></span><br><span class="line">怎么激活呢，由于历史原因A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20</span><br><span class="line">8042有两个IO端口：0x60和0x64， 激活流程位： 发送0xd1命令到0x64端口 --&gt; 发送0xdf到0x60，done！</span><br><span class="line"># seta20.1这些破东西叫标号。标号有唯一的名字加冒号组成。它可以出现在汇编程序的任何地方，并与紧跟其后的哪行代码具有相同的地址。概括的说 ，当程序中要跳转到另一位置时，需要有一个标识来指示新的位置，这就是标号，通过在目标地址的前面放上一个标号，可以在指令中使用标号来代替直接使用地址。</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line">#发送命令之前，要等待键盘输入缓冲区为空，这通过8042的状态寄存器的第2bit来观察，而状态寄存器的值可以读0x64端口得到。</span><br><span class="line">#上面的指令的意思就是，如果状态寄存器的第2位为1，就跳到seta20.1符号处执行，知道第2位为0，代表缓冲区为空</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line">发送0xd1到0x64端口</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">到此，A20激活完成。</span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑地址。这里使用的GDT通过gdtdesc段定义。它翻译得到的物理地址和虚拟地址相同，所以转换过程中内存映射不会改变</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">载入gdt</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line">打开保护模式标志位，相当于按下了保护模式的开关。cr0寄存器的第0位就是这个开关，通过CR0_PE_ON或cr0寄存器，将第0位置1</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line">由于上面的代码已经打开了保护模式了，所以这里要使用逻辑地址，而不是之前实模式的地址了。</span><br><span class="line">这里用到了PROT_MODE_CSEG, 他的值是0x8。根据段选择子的格式定义，0x8就翻译成：</span><br><span class="line">　　　　　　　　INDEX　　　　  TI     CPL</span><br><span class="line">            0000 0000 1    0      00</span><br><span class="line">INDEX代表GDT中的索引，TI代表使用GDTR中的GDT， CPL代表处于特权级。</span><br><span class="line"></span><br><span class="line">PROT_MODE_CSEG选择子选择了GDT中的第1个段描述符。这里使用的gdt就是变量gdt。下面可以看到gdt的第1个段描述符的基地址是0x0000,所以经过映射后和转换前的内存映射的物理地址一样。</span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">重新初始化各个段寄存器。</span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br><span class="line">栈顶设定在start处，也就是地址0x7c00处，call函数将返回地址入栈，将控制权交给bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure>
<p>CPU 使用全局描述符表寄存器 GDTR 保存段表起始地址。GDTR 长 48 位，其中高 32 位为基地址，低 16 位为段界限。<code>lgdt</code>指令将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 中（plus : lgdt 是间接寻址的）。载入 gdt 表，就是通过<code>lgdt gdtdesc</code>指令设置 GDTR 寄存器中的内容。</p>
<p>0x17 换成 10 进制就是 23,总共就有 24 个字节。一个 GDT 表项有 64 个 bit 占 8byte。总共 3 个表项一共就有 24 个字节。基地址 32 位是 gdt 这个标号所代表数据段的地址。GDT 的第一项总是为 0, 这就确保空段选择符的逻辑地址会被认为是无效的, 因此引起一个处理器异常.</p>
<p>上面的地址一共分了两段，第一段可执行可写，第二段可读，地址空间都覆盖整个 32 位 4GB 的保护模式空间。也正如之前 uCore 介绍的没有特别采用段机制</p>
<h3 id="如何使能和进入保护模式"><a href="#如何使能和进入保护模式" class="headerlink" title="如何使能和进入保护模式"></a>如何使能和进入保护模式</h3><p>因为我们无法直接操作 CR0，所以我们首先要用一个通用寄存器来保存当前 CR0 寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl %cr0, %eax</span><br><span class="line">orl $CR0_PE_ON, %eax  #CR0_PE_ON的值就是0x1</span><br><span class="line">movl %eax, %cr0       #保护模式打开</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>由于一些现代 CPU 特性 （乱序执行和分支预测等），在转到保护模式之后 CPU 可能仍然在跑着实模式下的代码，这显然会造成一些问题。因此必须强迫 CPU 清空一次缓冲。对此，最有效的方法就是进行一次 long jump</p>
<blockquote>
<p>ljmp &lt;imm1&gt;, &lt;imm2&gt; # %cs ← imm1 # %ip ← imm2</p>
</blockquote>
<p>由于上面的代码已经打开了保护模式了，所以这里要使用逻辑地址，而不是之前实模式的地址了。<br>这里用到了 PROT_MODE_CSEG, 他的值是 0x8。根据段选择子的格式定义，0x8 就翻译成：<br>| INDEX | TI | CPL |<br>| —– | — | — |<br>| 0000 0000 1 | 0 | 00 |<br>INDEX 代表 GDT 中的索引，TI 代表使用 GDTR 中的 GDT， CPL 代表处于特权级。</p>
<p>PROT_MODE_CSEG 选择子选择了 GDT 中的第 1 个段描述符。这里使用的 gdt 就是变量 gdt。下面可以看到 gdt 的第 1 个段描述符的基地址是 0x0000,所以经过映射后和转换前的内存映射的物理地址一样。</p>
<p>进入保护模式后,需要重新设置所有段寄存器的内容，现在 这些寄存器里面都需要保存段选择子，因为刚才的段表只把内存空间分成 2 段但这两段地址空间完全重合，实际上只有一段。所以这个时候所有的代码、数据、堆栈段都是在一个段选择子里，所以值都是 0x8,完成设置之后跳转到函数 bootmain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Bootload 的启动过程可以概括如下：</p>
<p>首先，BIOS 将第一块扇区（存着 bootloader）读到内存中物理地址为 0x7c00 的位置，同时段寄存器 CS 值为 0x0000，IP 值为 0x7c00，之后开始执行 bootloader 程序。CLI 屏蔽中断（屏蔽所有的中断：为中断提供服务通常是操作系统设备驱动程序的责任，因此在 bootloader 的执行全过程中可以不必响应任何中断，中断屏蔽是通过写 CPU 提供的中断屏蔽寄存器来完成的）；CLD 使 DF 复位，即 DF=0，通过执行 cld 指令可以控制方向标志 DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。设置寄存器 ax，ds，es，ss 寄存器值为 0；A20 门被关闭，高于 1MB 的地址都默认回卷到 0，所以要激活 A20，给 8042 发命令激活 A20，8042 有两个 IO 端口：0x60 和 0x64， 激活流程： 发送 0xd1 命令到 0x64 端口 –&gt; 发送 0xdf 到 0x60，打开 A20 门。从实模式转换到保护模式（实模式将整个物理内存看成一块区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，而且每一个指针都是指向实际的物理地址，地址就是 IP 值。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的），所以就初始化全局描述符表使得虚拟地址和物理地址匹配可以相互转换；lgdt 汇编指令把通过 gdt 处理后的（asm.h 头文件中处理函数）描述符表的起始位置和大小存入 gdtr 寄存器中；将 CR0 的第 0 号位设置为 1，进入保护模式；指令跳转由代码段跳到 protcseg 的起始位置。设置保护模式下数据段寄存器；设置堆栈寄存器并调用 bootmain 函数</p>
<h2 id="分析-bootloader-加载-ELF-格式的-OS-的过程"><a href="#分析-bootloader-加载-ELF-格式的-OS-的过程" class="headerlink" title="分析 bootloader 加载 ELF 格式的 OS 的过程"></a>分析 bootloader 加载 ELF 格式的 OS 的过程</h2><p>通过执行<code>readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0)</code>将 os 代码的 ELF 头读到内存中来。SECTSIZE=512 是扇区大小，ELFHDR 是存储 ELF 头格式的 OS 的地址。从磁盘 0 地址处（里面不算启动扇区，实际上是从第 1 个扇区开始读）读 SECTSIZE * 8 （8 个扇区） 读到 ELFHDR 这个地址上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count; <span class="comment">//终止地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//要读只能一个扇区一起读，将地址va与扇区开始处对齐，这样如果从对齐（减小过的va开始读取）的话，读完后没减过的实际传入没修改过的va就是我们想要的中间内容（注意va是传值调用进来的）</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>; <span class="comment">//算一算从哪个扇区开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno++)</span><br><span class="line">    &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个扇区读取的代码<code>dst</code>指示该扇区要读到的内存地址，<code>secno</code>指示读取磁盘的哪一个扇区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// 读几个扇区</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);  <span class="comment">//以下几个寄存器放扇区编号</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>); <span class="comment">// 操作内容，要求读扇区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取硬盘扇区的步骤：</p>
<ol>
<li><p>等待硬盘空闲。waitdisk 的函数实现只有一行：while ((inb(0x1F7) &amp; 0xC0) != 0x40)，意思是不断查询读 0x1F7 寄存器的最高两位，直到最高位为 0、次高位为 1（这个状态应该意味着磁盘空闲）才返回。</p>
</li>
<li><p>硬盘空闲后，发出读取扇区的命令。对应的命令字为 0x20，放在 0x1F7 寄存器中；读取的扇区数为 1，放在 0x1F2 寄存器中；读取的扇区起始编号共 28 位，分成 4 部分依次放在 0x1F3~0x1F6 寄存器中。</p>
</li>
<li><p>发出命令后，再次等待硬盘空闲。</p>
</li>
<li><p>硬盘再次空闲后，开始从 0x1F0 寄存器中读数据。注意 insl 的作用是”That function will read cnt dwords from the input port specified by port into the supplied output array addr.”，是以 dword 即 4 字节为单位的，因此这里 SECTIZE 需要除以 4.</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">insl(<span class="keyword">uint32_t</span> port, <span class="keyword">void</span> *addr, <span class="keyword">int</span> cnt) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;cld;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;repne; insl;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;=D&quot;</span> (addr), <span class="string">&quot;=c&quot;</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;d&quot;</span> (port), <span class="string">&quot;0&quot;</span> (addr), <span class="string">&quot;1&quot;</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取完 8 个扇区的操作系统后开始解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is this a valid ELF?</span></span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elf文件中的program header table</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// phoff: program header 表的起始位置偏移</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// phnum: program header 表中的入口数目</span></span><br><span class="line"><span class="comment">// program header 表是一个program header结构的数组， 每个结构描述了一个段或者系统准备程序执行所必需的其它信息</span></span><br><span class="line"><span class="comment">// eph 就是该表的终止位置</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//p_va virtual address to map segment</span></span><br><span class="line">    <span class="comment">//p_memsz size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="comment">//p_offset file offset of segment由于开始的地址是0，该偏移就是在磁盘中的实际地址</span></span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure>
<p>用工具读 kern 可以看到地址前面两位为空<code>&amp; 0xFFFFFF</code>的作用就是截取后面的 24 位地址，还有注意<code>ELFHDR-&gt;e_entry</code>的值为<code>0x100000</code>，<code>ELFHDR</code>的地址是<code>0x10000</code>,少一个 0，不是一个地址。</p>
<p><img src="https://md.lagrange.plus/uploads/upload_9f1f9e574d09eab7da5d82fd3636b561.png" alt="kern"></p>
<h2 id="实现函数调用堆栈跟踪函数"><a href="#实现函数调用堆栈跟踪函数" class="headerlink" title="实现函数调用堆栈跟踪函数"></a>实现函数调用堆栈跟踪函数</h2><p>几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl   %ebp</span><br><span class="line">movl   %esp , %ebp</span><br></pre></td></tr></table></figure>

<p>这样在程序执行到一个函数的实际指令前，已经有以下数据顺序入栈：参数、返回地址、ebp 寄存器。由此得到类似如下的栈结构（参数入栈顺序跟调用方式有关，这里以 C 语言默认的 CDECL 为例）：</p>
<p><img src="https://md.lagrange.plus/uploads/upload_11fd42ee568230926dd27f08d50957e6.png" alt="stack"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">//#define STACKFRAME_DEPTH 20</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);</span><br><span class="line">        <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>, args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">        eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">        ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义两个局部变量 ebp、esp 分别存放 ebp、esp 寄存器的值。这里将 ebp 定义为指针，是为了方便后面取 ebp 寄存器的值。</p>
<p>调用 read_ebp 函数来获取执行 print_stackframe 函数时 ebp 寄存器的值，这里 read_ebp 必须定义为 inline 函数，否则获取的是执行 read_ebp 函数时的 ebp 寄存器的值。</p>
<p>调用 read_eip 函数来获取当前指令的位置，也就是此时 eip 寄存器的值。这里 read_eip 必须定义为常规函数而不是 inline 函数，因为这样的话在调用 read_eip 时会把当前 ebp 压栈，把 ebp 设置为 eip，故只要读调用函数后的 ebp 就可得到当前 eip 的值。</p>
<p>由于变量 eip 存放的是下一条指令的地址，因此将变量 eip 的值减去 1，得到的指令地址就属于当前指令的范围了。由于只要输入的地址属于当前指令的起始和结束位置之间，print_debuginfo 都能搜索到当前指令，因此这里减去 1 即可。</p>
<p>以后变量 eip 的值就不能再调用 read_eip 来获取了（每次调用获取的值都是相同的），而应该从 ebp 寄存器指向栈中的位置再往上一个单位中获取。这个地址指向上一个栈帧的最后入栈的元素。</p>
<p>由于 ebp 寄存器指向栈中的位置存放的是调用者的 ebp 寄存器的值，把现在的地址更新为这个地址里面存储的内容，据此可以继续顺藤摸瓜，不断回溯，直到 ebp 寄存器的值变为 0</p>
<h2 id="int-0x80系统调用实现"><a href="#int-0x80系统调用实现" class="headerlink" title="int 0x80系统调用实现"></a><code>int 0x80</code>系统调用实现</h2><p>CS 作为段基址寄存器储存着段选择子，里面包含 GDT 表的偏移以及当前的特权级 CPL。对于用户态程序来说 CPL 一般为 3，内核段的 DPL 都是 0，无法直接访问内核的数据与代码，若需要访问则需要通过中断实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++) &#123;</span><br><span class="line">    SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set for switch from user to kernel</span></span><br><span class="line">SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br></pre></td></tr></table></figure>
<p>在设置中断向量表 IDT 的时候，故意将<code>T_SWITCH_TOK=0x79</code>(实际是第 0x80 项)的 DPL 设置为用户态权限 3，其余都设置为内核态 0.<br><img src="https://md.lagrange.plus/uploads/upload_85d13f38c3c4636e196ba2a53b33436f.png" alt="IDT"></p>
<p>每个 IDT 表项如上图所示，当一个程序引发 0x80 中断时，CPU 通过硬件检查 IDT 中对应的 DPL 特权级，发现为 3 可以访问，然后将对应的段选择符和入口偏移装入 CS：IP，该段选择符的 CPL 为 0，即进入内核，可以通过系统调用操作一些内存数据。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/24/Lab2/" rel="prev" title="Lab2 实验报告">
      <i class="fa fa-chevron-left"></i> Lab2 实验报告
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/24/Lab4/" rel="next" title="Lab4 实验报告">
      Lab4 实验报告 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="nav-number">1.</span> <span class="nav-text">Lab1 实验报告</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#make-%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">make 生成执行文件的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6-ucore-img-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%9F%E6%88%90%E7%9A%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">操作系统镜像文件 ucore.img 是如何一步一步生成的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%B3%BB%E7%BB%9F%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83%E7%9A%84%E7%A1%AC%E7%9B%98%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">一个被系统认为是符合规范的硬盘主引导扇区的特征是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统启动过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">分析 bootloader 进入保护模式的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E5%BC%80%E5%90%AF-A20%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF-A20"><span class="nav-number">1.3.1.</span> <span class="nav-text">为何开启 A20，以及如何开启 A20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96-GDT-%E8%A1%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">如何初始化 GDT 表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E8%83%BD%E5%92%8C%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">如何使能和进入保护模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90-bootloader-%E5%8A%A0%E8%BD%BD-ELF-%E6%A0%BC%E5%BC%8F%E7%9A%84-OS-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">分析 bootloader 加载 ELF 格式的 OS 的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">实现函数调用堆栈跟踪函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-0x80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.</span> <span class="nav-text">int 0x80系统调用实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lagrange</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lagrange</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
